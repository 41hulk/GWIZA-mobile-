{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=ScenesReducer;var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _invariant=_interopRequireDefault(require(\"../utils/invariant\"));var _shallowEqual=_interopRequireDefault(require(\"../utils/shallowEqual\"));var SCENE_KEY_PREFIX='scene_';function compareKey(one,two){var delta=one.length-two.length;if(delta>0){return 1;}if(delta<0){return-1;}return one>two?1:-1;}function compareScenes(one,two){if(one.index>two.index){return 1;}if(one.index<two.index){return-1;}return compareKey(one.key,two.key);}function areScenesShallowEqual(one,two){return one.key===two.key&&one.index===two.index&&one.isStale===two.isStale&&one.isActive===two.isActive&&areRoutesShallowEqual(one.route,two.route);}function areRoutesShallowEqual(one,two){if(!one||!two){return one===two;}if(one.key!==two.key){return false;}return(0,_shallowEqual.default)(one,two);}function ScenesReducer(scenes,nextState,prevState,descriptors){scenes.forEach(function(scene){var route=scene.route;if(descriptors&&descriptors[route.key]){scene.descriptor=descriptors[route.key];}});if(prevState===nextState){return scenes;}var prevScenes=new Map();var freshScenes=new Map();var staleScenes=new Map();scenes.forEach(function(scene){var key=scene.key;if(scene.isStale){staleScenes.set(key,scene);}prevScenes.set(key,scene);});var nextKeys=new Set();var nextRoutes=nextState.routes;if(nextRoutes.length>nextState.index+1){console.warn('StackRouter provided invalid state, index should always be the top route');nextRoutes=nextState.routes.slice(0,nextState.index+1);}nextRoutes.forEach(function(route,index){var key=SCENE_KEY_PREFIX+route.key;var descriptor=descriptors&&descriptors[route.key];var scene={index:index,isActive:false,isStale:false,key:key,route:route,descriptor:descriptor};(0,_invariant.default)(!nextKeys.has(key),\"navigation.state.routes[\"+index+\"].key \\\"\"+key+\"\\\" conflicts with \"+'another route!');nextKeys.add(key);if(staleScenes.has(key)){staleScenes.delete(key);}freshScenes.set(key,scene);});if(prevState){var prevRoutes=prevState.routes;if(prevRoutes.length>prevState.index+1){console.warn('StackRouter provided invalid state, index should always be the top route');prevRoutes=prevRoutes.slice(0,prevState.index+1);}prevRoutes.forEach(function(route,index){var key=SCENE_KEY_PREFIX+route.key;if(freshScenes.has(key)){return;}var lastScene=scenes.find(function(scene){return scene.route.key===route.key;});var descriptor=lastScene?lastScene.descriptor:descriptors[route.key];if(descriptor){staleScenes.set(key,{index:index,isActive:false,isStale:true,key:key,route:route,descriptor:descriptor});}});}var nextScenes=[];var mergeScene=function mergeScene(nextScene){var key=nextScene.key;var prevScene=prevScenes.has(key)?prevScenes.get(key):null;if(prevScene&&areScenesShallowEqual(prevScene,nextScene)){nextScenes.push(prevScene);}else{nextScenes.push(nextScene);}};staleScenes.forEach(mergeScene);freshScenes.forEach(mergeScene);nextScenes.sort(compareScenes);var activeScenesCount=0;nextScenes.forEach(function(scene,ii){var isActive=!scene.isStale&&scene.index===nextState.index;if(isActive!==scene.isActive){nextScenes[ii]=(0,_objectSpread2.default)({},scene,{isActive:isActive});}if(isActive){activeScenesCount++;}});(0,_invariant.default)(activeScenesCount===1,'there should always be only one scene active, not %s.',activeScenesCount);if(nextScenes.length!==scenes.length){return nextScenes;}if(nextScenes.some(function(scene,index){return!areScenesShallowEqual(scenes[index],scene);})){return nextScenes;}return scenes;}","map":{"version":3,"sources":["/Users/ntareguy/Downloads/gwizamobile1/node_modules/react-navigation-stack/dist/views/ScenesReducer.js"],"names":["SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","nextRoutes","routes","console","warn","slice","has","add","delete","prevRoutes","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one, two) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor\n    };\n    invariant(!nextKeys.has(key), `navigation.state.routes[${index}].key \"${key}\" conflicts with ` + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor\n        });\n      }\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = nextScene => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some((scene, index) => !areScenesShallowEqual(scenes[index], scene))) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}"]},"metadata":{},"sourceType":"script"}