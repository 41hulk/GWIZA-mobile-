{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.Sound=void 0;var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _reactNative=require(\"react-native\");var _AudioAvailability=require(\"./AudioAvailability\");var _AV=require(\"../AV\");var Sound=function(){function Sound(){var _this=this;(0,_classCallCheck2.default)(this,Sound);this._loaded=false;this._loading=false;this._key=-1;this._lastStatusUpdate=null;this._lastStatusUpdateTime=null;this._subscriptions=[];this._eventEmitter=new _reactNative.NativeEventEmitter(_reactNative.NativeModules.ExponentAV);this._coalesceStatusUpdatesInMillis=100;this._onPlaybackStatusUpdate=null;this._internalStatusUpdateCallback=function(_ref){var key=_ref.key,status=_ref.status;if(_this._key===key){_this._callOnPlaybackStatusUpdateForNewStatus(status);}};this._errorCallback=function(error){_this._clearSubscriptions();_this._loaded=false;_this._key=-1;_this._callOnPlaybackStatusUpdateForNewStatus((0,_AV.getUnloadedStatus)(error));};this.getStatusAsync=function _callee(){var status;return _regenerator.default.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!_this._loaded){_context.next=2;break;}return _context.abrupt(\"return\",_this._performOperationAndHandleStatusAsync(function(){return _reactNative.NativeModules.ExponentAV.getStatusForSound(_this._key);}));case 2:status=(0,_AV.getUnloadedStatus)();_this._callOnPlaybackStatusUpdateForNewStatus(status);return _context.abrupt(\"return\",status);case 5:case\"end\":return _context.stop();}}},null,this);};}(0,_createClass2.default)(Sound,[{key:\"_callOnPlaybackStatusUpdateForNewStatus\",value:function _callOnPlaybackStatusUpdateForNewStatus(status){var shouldDismissBasedOnCoalescing=this._lastStatusUpdateTime&&JSON.stringify(status)===this._lastStatusUpdate&&Date.now()-this._lastStatusUpdateTime.getTime()<this._coalesceStatusUpdatesInMillis;if(this._onPlaybackStatusUpdate!=null&&!shouldDismissBasedOnCoalescing){this._onPlaybackStatusUpdate(status);this._lastStatusUpdateTime=new Date();this._lastStatusUpdate=JSON.stringify(status);}}},{key:\"_performOperationAndHandleStatusAsync\",value:function _performOperationAndHandleStatusAsync(operation){var status;return _regenerator.default.async(function _performOperationAndHandleStatusAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:(0,_AudioAvailability.throwIfAudioIsDisabled)();if(!this._loaded){_context2.next=9;break;}_context2.next=4;return _regenerator.default.awrap(operation());case 4:status=_context2.sent;this._callOnPlaybackStatusUpdateForNewStatus(status);return _context2.abrupt(\"return\",status);case 9:throw new Error('Cannot complete operation because sound is not loaded.');case 10:case\"end\":return _context2.stop();}}},null,this);}},{key:\"_subscribeToNativeStatusUpdateEvents\",value:function _subscribeToNativeStatusUpdateEvents(){if(this._loaded){this._subscriptions.push(this._eventEmitter.addListener('didUpdatePlaybackStatus',this._internalStatusUpdateCallback));}}},{key:\"_clearSubscriptions\",value:function _clearSubscriptions(){this._subscriptions.forEach(function(e){return e.remove();});this._subscriptions=[];}},{key:\"setOnPlaybackStatusUpdate\",value:function setOnPlaybackStatusUpdate(onPlaybackStatusUpdate){this._onPlaybackStatusUpdate=onPlaybackStatusUpdate;this.getStatusAsync();}},{key:\"loadAsync\",value:function loadAsync(source){var _this2=this;var initialStatus,downloadFirst,_ref2,nativeSource,fullInitialStatus,_args3=arguments;return _regenerator.default.async(function loadAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:initialStatus=_args3.length>1&&_args3[1]!==undefined?_args3[1]:{};downloadFirst=_args3.length>2&&_args3[2]!==undefined?_args3[2]:true;(0,_AudioAvailability.throwIfAudioIsDisabled)();if(!this._loading){_context3.next=5;break;}throw new Error('The Sound is already loading.');case 5:if(this._loaded){_context3.next=15;break;}this._loading=true;_context3.next=9;return _regenerator.default.awrap((0,_AV.getNativeSourceAndFullInitialStatusForLoadAsync)(source,initialStatus,downloadFirst));case 9:_ref2=_context3.sent;nativeSource=_ref2.nativeSource;fullInitialStatus=_ref2.fullInitialStatus;return _context3.abrupt(\"return\",new Promise(function(resolve,reject){var loadSuccess=function loadSuccess(key,status){_this2._key=key;_this2._loaded=true;_this2._loading=false;_reactNative.NativeModules.ExponentAV.setErrorCallbackForSound(_this2._key,_this2._errorCallback);_this2._subscribeToNativeStatusUpdateEvents();_this2._callOnPlaybackStatusUpdateForNewStatus(status);resolve(status);};var loadError=function loadError(error){_this2._loading=false;reject(new Error(error));};_reactNative.NativeModules.ExponentAV.loadForSound(nativeSource,fullInitialStatus,loadSuccess,loadError);}));case 15:throw new Error('The Sound is already loaded.');case 16:case\"end\":return _context3.stop();}}},null,this);}},{key:\"unloadAsync\",value:function unloadAsync(){var key,status;return _regenerator.default.async(function unloadAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!this._loaded){_context4.next=12;break;}this._loaded=false;key=this._key;this._key=-1;_context4.next=6;return _regenerator.default.awrap(_reactNative.NativeModules.ExponentAV.unloadForSound(key));case 6:status=_context4.sent;this._callOnPlaybackStatusUpdateForNewStatus(status);this._clearSubscriptions();return _context4.abrupt(\"return\",status);case 12:return _context4.abrupt(\"return\",this.getStatusAsync());case 13:case\"end\":return _context4.stop();}}},null,this);}},{key:\"setStatusAsync\",value:function setStatusAsync(status){var _this3=this;return _regenerator.default.async(function setStatusAsync$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:(0,_AV.assertStatusValuesInBounds)(status);return _context5.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return _reactNative.NativeModules.ExponentAV.setStatusForSound(_this3._key,status);}));case 2:case\"end\":return _context5.stop();}}},null,this);}},{key:\"replayAsync\",value:function replayAsync(){var _this4=this;var status,_args6=arguments;return _regenerator.default.async(function replayAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:status=_args6.length>0&&_args6[0]!==undefined?_args6[0]:{};if(!(status.positionMillis&&status.positionMillis!==0)){_context6.next=3;break;}throw new Error('Requested position after replay has to be 0.');case 3:return _context6.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return _reactNative.NativeModules.ExponentAV.replaySound(_this4._key,(0,_objectSpread2.default)({},status,{positionMillis:0,shouldPlay:true}));}));case 4:case\"end\":return _context6.stop();}}},null,this);}}]);return Sound;}();exports.Sound=Sound;Sound.create=function _callee2(source){var initialStatus,onPlaybackStatusUpdate,downloadFirst,_args7=arguments;return _regenerator.default.async(function _callee2$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:initialStatus=_args7.length>1&&_args7[1]!==undefined?_args7[1]:{};onPlaybackStatusUpdate=_args7.length>2&&_args7[2]!==undefined?_args7[2]:null;downloadFirst=_args7.length>3&&_args7[3]!==undefined?_args7[3]:true;console.warn(\"Sound.create is deprecated in favor of Sound.createAsync with the same API except for the new method name\");return _context7.abrupt(\"return\",Sound.createAsync(source,initialStatus,onPlaybackStatusUpdate,downloadFirst));case 5:case\"end\":return _context7.stop();}}},null,this);};Sound.createAsync=function _callee3(source){var initialStatus,onPlaybackStatusUpdate,downloadFirst,sound,status,_args8=arguments;return _regenerator.default.async(function _callee3$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:initialStatus=_args8.length>1&&_args8[1]!==undefined?_args8[1]:{};onPlaybackStatusUpdate=_args8.length>2&&_args8[2]!==undefined?_args8[2]:null;downloadFirst=_args8.length>3&&_args8[3]!==undefined?_args8[3]:true;sound=new Sound();sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);_context8.next=7;return _regenerator.default.awrap(sound.loadAsync(source,initialStatus,downloadFirst));case 7:status=_context8.sent;return _context8.abrupt(\"return\",{sound:sound,status:status});case 9:case\"end\":return _context8.stop();}}},null,this);};(0,_extends2.default)(Sound.prototype,_AV.PlaybackMixin);","map":{"version":3,"sources":["../../../src/av/Audio/Sound.ts"],"names":[],"mappings":"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","sourcesContent":["import { NativeEventEmitter, NativeModules } from 'react-native';\n\nimport { throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  Playback,\n  PlaybackMixin,\n  PlaybackSource,\n  PlaybackStatus,\n  PlaybackStatusToSet,\n  assertStatusValuesInBounds,\n  getNativeSourceAndFullInitialStatusForLoadAsync,\n  getUnloadedStatus,\n} from '../AV';\n\nexport class Sound implements Playback {\n  _loaded: boolean = false;\n  _loading: boolean = false;\n  _key: number = -1;\n  _lastStatusUpdate: string | null = null;\n  _lastStatusUpdateTime: Date | null = null;\n  _subscriptions: Array<{ remove: () => void }> = [];\n  _eventEmitter: NativeEventEmitter = new NativeEventEmitter(NativeModules.ExponentAV);\n  _coalesceStatusUpdatesInMillis: number = 100;\n  _onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null;\n\n  static create = async (\n    source: PlaybackSource,\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> => {\n    console.warn(\n      `Sound.create is deprecated in favor of Sound.createAsync with the same API except for the new method name`\n    );\n    return Sound.createAsync(source, initialStatus, onPlaybackStatusUpdate, downloadFirst);\n  };\n\n  static createAsync = async (\n    source: PlaybackSource,\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null,\n    downloadFirst: boolean = true\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> => {\n    const sound: Sound = new Sound();\n    sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n    const status: PlaybackStatus = await sound.loadAsync(source, initialStatus, downloadFirst);\n    return { sound, status };\n  };\n\n  // Internal methods\n\n  _callOnPlaybackStatusUpdateForNewStatus(status: PlaybackStatus) {\n    const shouldDismissBasedOnCoalescing =\n      this._lastStatusUpdateTime &&\n      JSON.stringify(status) === this._lastStatusUpdate &&\n      Date.now() - this._lastStatusUpdateTime.getTime() < this._coalesceStatusUpdatesInMillis;\n\n    if (this._onPlaybackStatusUpdate != null && !shouldDismissBasedOnCoalescing) {\n      this._onPlaybackStatusUpdate(status);\n      this._lastStatusUpdateTime = new Date();\n      this._lastStatusUpdate = JSON.stringify(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<PlaybackStatus>\n  ): Promise<PlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loaded) {\n      const status = await operation();\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because sound is not loaded.');\n    }\n  }\n\n  _internalStatusUpdateCallback = ({ key, status }: { key: number; status: PlaybackStatus }) => {\n    if (this._key === key) {\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n    }\n  };\n\n  // TODO: We can optimize by only using time observer on native if (this._onPlaybackStatusUpdate).\n  _subscribeToNativeStatusUpdateEvents() {\n    if (this._loaded) {\n      this._subscriptions.push(\n        this._eventEmitter.addListener(\n          'didUpdatePlaybackStatus',\n          this._internalStatusUpdateCallback\n        )\n      );\n    }\n  }\n\n  _clearSubscriptions() {\n    this._subscriptions.forEach(e => e.remove());\n    this._subscriptions = [];\n  }\n\n  _errorCallback = (error: string) => {\n    this._clearSubscriptions();\n    this._loaded = false;\n    this._key = -1;\n    this._callOnPlaybackStatusUpdateForNewStatus(getUnloadedStatus(error));\n  };\n\n  // ### Unified playback API ### (consistent with Video.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<PlaybackStatus> => {\n    if (this._loaded) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        NativeModules.ExponentAV.getStatusForSound(this._key)\n      );\n    }\n    const status: PlaybackStatus = getUnloadedStatus();\n    this._callOnPlaybackStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnPlaybackStatusUpdate(onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  // Loading / unloading API\n\n  async loadAsync(\n    source: PlaybackSource,\n    initialStatus: PlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<PlaybackStatus> {\n    throwIfAudioIsDisabled();\n    if (this._loading) {\n      throw new Error('The Sound is already loading.');\n    }\n    if (!this._loaded) {\n      this._loading = true;\n\n      const {\n        nativeSource,\n        fullInitialStatus,\n      } = await getNativeSourceAndFullInitialStatusForLoadAsync(\n        source,\n        initialStatus,\n        downloadFirst\n      );\n\n      // This is a workaround, since using load with resolve / reject seems to not work.\n      return new Promise<PlaybackStatus>((resolve, reject) => {\n        const loadSuccess = (key: number, status: PlaybackStatus) => {\n          this._key = key;\n          this._loaded = true;\n          this._loading = false;\n          NativeModules.ExponentAV.setErrorCallbackForSound(this._key, this._errorCallback);\n          this._subscribeToNativeStatusUpdateEvents();\n          this._callOnPlaybackStatusUpdateForNewStatus(status);\n          resolve(status);\n        };\n\n        const loadError = (error: string) => {\n          this._loading = false;\n          reject(new Error(error));\n        };\n\n        NativeModules.ExponentAV.loadForSound(\n          nativeSource,\n          fullInitialStatus,\n          loadSuccess,\n          loadError\n        );\n      });\n    } else {\n      throw new Error('The Sound is already loaded.');\n    }\n  }\n\n  async unloadAsync(): Promise<PlaybackStatus> {\n    if (this._loaded) {\n      this._loaded = false;\n      const key = this._key;\n      this._key = -1;\n      const status = await NativeModules.ExponentAV.unloadForSound(key);\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      this._clearSubscriptions();\n      return status;\n    } else {\n      return this.getStatusAsync(); // Automatically calls onPlaybackStatusUpdate.\n    }\n  }\n\n  // Set status API (only available while isLoaded = true)\n\n  async setStatusAsync(status: PlaybackStatusToSet): Promise<PlaybackStatus> {\n    assertStatusValuesInBounds(status);\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.setStatusForSound(this._key, status)\n    );\n  }\n\n  async replayAsync(status: PlaybackStatusToSet = {}): Promise<PlaybackStatus> {\n    if (status.positionMillis && status.positionMillis !== 0) {\n      throw new Error('Requested position after replay has to be 0.');\n    }\n\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.replaySound(this._key, {\n        ...status,\n        positionMillis: 0,\n        shouldPlay: true,\n      })\n    );\n  }\n\n  // Methods of the Playback interface that are set via PlaybackMixin\n  playAsync!: () => Promise<PlaybackStatus>;\n  playFromPositionAsync!: (\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ) => Promise<PlaybackStatus>;\n  pauseAsync!: () => Promise<PlaybackStatus>;\n  stopAsync!: () => Promise<PlaybackStatus>;\n  setPositionAsync!: (\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ) => Promise<PlaybackStatus>;\n  setRateAsync!: (rate: number, shouldCorrectPitch: boolean) => Promise<PlaybackStatus>;\n  setVolumeAsync!: (volume: number) => Promise<PlaybackStatus>;\n  setIsMutedAsync!: (isMuted: boolean) => Promise<PlaybackStatus>;\n  setIsLoopingAsync!: (isLooping: boolean) => Promise<PlaybackStatus>;\n  setProgressUpdateIntervalAsync!: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<PlaybackStatus>;\n}\n\nObject.assign(Sound.prototype, PlaybackMixin);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}