{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=exports.EXPO_CONSOLE_METHOD_NAME=void 0;var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _toConsumableArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));var _expoConstants=require(\"expo-constants\");var _prettyFormat=_interopRequireDefault(require(\"pretty-format\"));var _parseErrorStack=_interopRequireDefault(require(\"react-native/Libraries/Core/Devtools/parseErrorStack\"));var _symbolicateStackTrace=_interopRequireDefault(require(\"react-native/Libraries/Core/Devtools/symbolicateStackTrace\"));var EXPO_CONSOLE_METHOD_NAME='__expoConsoleLog';exports.EXPO_CONSOLE_METHOD_NAME=EXPO_CONSOLE_METHOD_NAME;function serializeLogDataAsync(data,level){var serializedValues,includesStack,rawStack,syntheticError,stack,errorMessage,serializedError,error,_errorMessage,_serializedError;return _regenerator.default.async(function serializeLogDataAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:includesStack=false;if(!_stackTraceLogsSupported()){_context.next=32;break;}if(!_isUnhandledPromiseRejection(data,level)){_context.next=11;break;}rawStack=data[0];syntheticError={stack:rawStack};_context.next=7;return _regenerator.default.awrap(_symbolicateErrorAsync(syntheticError));case 7:stack=_context.sent;if(!stack.length){serializedValues=_stringifyLogData(data);}else{errorMessage=rawStack.split('\\n')[1];serializedValues=[{message:\"[Unhandled promise rejection: \"+errorMessage+\"]\",stack:_formatStack(stack)}];includesStack=true;}_context.next=30;break;case 11:if(!(data.length===1&&data[0]instanceof Error)){_context.next=19;break;}_context.next=14;return _regenerator.default.awrap(_serializeErrorAsync(data[0]));case 14:serializedError=_context.sent;serializedValues=[serializedError];includesStack=serializedError.hasOwnProperty('stack');_context.next=30;break;case 19:if(!(level==='warn'||level==='error')){_context.next=29;break;}error=_captureConsoleStackTrace();_errorMessage=_stringifyLogData(data).join(', ');_context.next=24;return _regenerator.default.awrap(_serializeErrorAsync(error,_errorMessage));case 24:_serializedError=_context.sent;serializedValues=[_serializedError];includesStack=_serializedError.hasOwnProperty('stack');_context.next=30;break;case 29:serializedValues=_stringifyLogData(data);case 30:_context.next=33;break;case 32:serializedValues=_stringifyLogData(data);case 33:return _context.abrupt(\"return\",{body:(0,_toConsumableArray2.default)(serializedValues),includesStack:includesStack});case 34:case\"end\":return _context.stop();}}},null,this);}function _stringifyLogData(data){return data.map(function(item){if(typeof item==='string'){return item;}else{return(0,_prettyFormat.default)(item);}});}function _serializeErrorAsync(error,message){var stack,formattedStack;return _regenerator.default.async(function _serializeErrorAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(message==null){message=error.message;}if(!(!error.stack||!error.stack.length)){_context2.next=3;break;}return _context2.abrupt(\"return\",(0,_prettyFormat.default)(error));case 3:_context2.next=5;return _regenerator.default.awrap(_symbolicateErrorAsync(error));case 5:stack=_context2.sent;formattedStack=_formatStack(stack);return _context2.abrupt(\"return\",{message:message,stack:formattedStack});case 8:case\"end\":return _context2.stop();}}},null,this);}function _symbolicateErrorAsync(error){var parsedStack,symbolicatedStack;return _regenerator.default.async(function _symbolicateErrorAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:parsedStack=(0,_parseErrorStack.default)(error);_context3.prev=1;_context3.next=4;return _regenerator.default.awrap((0,_symbolicateStackTrace.default)(parsedStack));case 4:symbolicatedStack=_context3.sent;_context3.next=10;break;case 7:_context3.prev=7;_context3.t0=_context3[\"catch\"](1);return _context3.abrupt(\"return\",parsedStack);case 10:if(symbolicatedStack){_context3.next=12;break;}return _context3.abrupt(\"return\",parsedStack);case 12:return _context3.abrupt(\"return\",symbolicatedStack.map(_removeProjectRoot));case 13:case\"end\":return _context3.stop();}}},null,this,[[1,7]]);}function _formatStack(stack){return stack.map(function(frame){var line=frame.file+\":\"+frame.lineNumber;if(frame.column!=null){line+=\":\"+frame.column;}line+=\" in \"+frame.methodName;return line;}).join('\\n');}function _removeProjectRoot(frame){var filename=frame.file;if(filename==null){return frame;}var projectRoot=_getProjectRoot();if(projectRoot==null){return frame;}if(filename.startsWith(projectRoot)){filename=filename.substring(projectRoot.length);if(filename[0]==='/'||filename[0]==='\\\\'){filename=filename.substring(1);}frame.file=filename;}return frame;}function _stackTraceLogsSupported(){return!!(__DEV__&&_getProjectRoot());}function _isUnhandledPromiseRejection(data,level){return level==='warn'&&typeof data[0]==='string'&&/^Possible Unhandled Promise Rejection/.test(data[0]);}function _captureConsoleStackTrace(){try{throw new Error();}catch(error){var stackLines=error.stack.split('\\n');var consoleMethodIndex=stackLines.findIndex(function(frame){return frame.includes(EXPO_CONSOLE_METHOD_NAME);});if(consoleMethodIndex!==-1){stackLines=stackLines.slice(consoleMethodIndex+1);error.stack=stackLines.join('\\n');}return error;}}function _getProjectRoot(){return _expoConstants.Constants.manifest&&_expoConstants.Constants.manifest.developer?_expoConstants.Constants.manifest.developer.projectRoot:null;}var _default={serializeLogDataAsync:serializeLogDataAsync};exports.default=_default;","map":{"version":3,"sources":["../../src/logs/LogSerialization.ts"],"names":[],"mappings":"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","sourcesContent":["import { Constants } from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack, { StackFrame } from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\n\nimport { LogData, LogLevel } from './RemoteLogging';\n\ntype SerializedData = {\n  body: LogData[];\n  includesStack: boolean;\n};\n\nexport const EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nasync function serializeLogDataAsync(data: unknown[], level: LogLevel): Promise<SerializedData> {\n  let serializedValues: ReadonlyArray<LogData>;\n  let includesStack = false;\n\n  if (_stackTraceLogsSupported()) {\n    if (_isUnhandledPromiseRejection(data, level)) {\n      let rawStack = data[0] as string;\n      let syntheticError = { stack: rawStack };\n      let stack = await _symbolicateErrorAsync(syntheticError as Error);\n\n      if (!stack.length) {\n        serializedValues = _stringifyLogData(data);\n      } else {\n        // NOTE: This doesn't handle error messages with newlines\n        let errorMessage = rawStack.split('\\n')[1];\n        serializedValues = [\n          {\n            message: `[Unhandled promise rejection: ${errorMessage}]`,\n            stack: _formatStack(stack),\n          },\n        ];\n        includesStack = true;\n      }\n    } else if (data.length === 1 && data[0] instanceof Error) {\n      // When there's only one argument to the log function and that argument is an error, we\n      // include the error's stack. If there's more than one argument then we don't include the\n      // stack because it's not easy to display nicely in our current UI.\n\n      let serializedError = await _serializeErrorAsync(data[0] as Error);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else if (level === 'warn' || level === 'error') {\n      // For console.warn and console.error it is usually useful to know the stack that leads to the\n      // warning or error, so we provide this information to help out with debugging\n\n      let error = _captureConsoleStackTrace();\n      // [\"hello\", \"world\"] becomes \"hello, world\"\n      let errorMessage = _stringifyLogData(data).join(', ');\n\n      let serializedError = await _serializeErrorAsync(error, errorMessage);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n  } else {\n    serializedValues = _stringifyLogData(data);\n  }\n\n  return {\n    body: [...serializedValues],\n    includesStack,\n  };\n}\n\nfunction _stringifyLogData(data: unknown[]): string[] {\n  return data.map(item => {\n    if (typeof item === 'string') {\n      return item;\n    } else {\n      return prettyFormat(item);\n    }\n  });\n}\n\nasync function _serializeErrorAsync(error: Error, message?: string): Promise<LogData> {\n  if (message == null) {\n    message = error.message;\n  }\n\n  if (!error.stack || !error.stack.length) {\n    return prettyFormat(error);\n  }\n\n  let stack = await _symbolicateErrorAsync(error);\n  let formattedStack = _formatStack(stack);\n\n  return { message, stack: formattedStack };\n}\n\nasync function _symbolicateErrorAsync(error: Error): Promise<StackFrame[]> {\n  let parsedStack = parseErrorStack(error);\n  let symbolicatedStack: StackFrame[] | null;\n  try {\n    symbolicatedStack = await symbolicateStackTrace(parsedStack);\n  } catch (error) {\n    return parsedStack;\n  }\n\n  // In this context an unsymbolicated stack is better than no stack\n  if (!symbolicatedStack) {\n    return parsedStack;\n  }\n\n  // Clean the stack trace\n  return symbolicatedStack.map(_removeProjectRoot);\n}\n\nfunction _formatStack(stack: StackFrame[]): string {\n  return stack\n    .map(frame => {\n      let line = `${frame.file}:${frame.lineNumber}`;\n      if (frame.column != null) {\n        line += `:${frame.column}`;\n      }\n      line += ` in ${frame.methodName}`;\n      return line;\n    })\n    .join('\\n');\n}\n\nfunction _removeProjectRoot(frame: StackFrame): StackFrame {\n  let filename = frame.file;\n  if (filename == null) {\n    return frame;\n  }\n\n  let projectRoot = _getProjectRoot();\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\n/**\n * Returns whether the development server that served this project supports logs with a stack trace.\n * Specifically, the version of Expo CLI that includes `projectRoot` in the manifest also accepts\n * payloads of the form:\n *\n * {\n *   includesStack: boolean, body: [{ message: string, stack: string }],\n * }\n */\nfunction _stackTraceLogsSupported(): boolean {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data: unknown[], level: LogLevel): boolean {\n  return (\n    level === 'warn' &&\n    typeof data[0] === 'string' &&\n    /^Possible Unhandled Promise Rejection/.test(data[0] as string)\n  );\n}\n\nfunction _captureConsoleStackTrace(): Error {\n  try {\n    throw new Error();\n  } catch (error) {\n    let stackLines = error.stack.split('\\n');\n    let consoleMethodIndex = stackLines.findIndex(frame =>\n      frame.includes(EXPO_CONSOLE_METHOD_NAME)\n    );\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n    return error;\n  }\n}\n\nfunction _getProjectRoot(): string | null {\n  return Constants.manifest && Constants.manifest.developer\n    ? Constants.manifest.developer.projectRoot\n    : null;\n}\n\nexport default {\n  serializeLogDataAsync,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}