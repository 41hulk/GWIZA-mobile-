{"ast":null,"code":"var _interopRequireWildcard=require(\"@babel/runtime/helpers/interopRequireWildcard\");var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _react=_interopRequireWildcard(require(\"react\"));var _reactNative=require(\"react-native\");var _invariant=_interopRequireDefault(require(\"invariant\"));var _AnimatedEvent=require(\"react-native/Libraries/Animated/src/AnimatedEvent\");var _reactNativeGestureHandler=require(\"react-native-gesture-handler\");var DRAG_TOSS=0.05;var IDLE='Idle';var DRAGGING='Dragging';var SETTLING='Settling';var DrawerLayout=function(_Component){(0,_inherits2.default)(DrawerLayout,_Component);function DrawerLayout(_props,context){var _this;(0,_classCallCheck2.default)(this,DrawerLayout);_this=(0,_possibleConstructorReturn2.default)(this,(0,_getPrototypeOf2.default)(DrawerLayout).call(this,_props,context));_this._updateAnimatedEvent=function(props,state){var drawerPosition=props.drawerPosition,drawerWidth=props.drawerWidth,drawerType=props.drawerType;var dragXValue=state.dragX,touchXValue=state.touchX,drawerTranslation=state.drawerTranslation,containerWidth=state.containerWidth;var dragX=dragXValue;var touchX=touchXValue;if(drawerPosition!=='left'){dragX=_reactNative.Animated.multiply(new _reactNative.Animated.Value(-1),dragXValue);touchX=_reactNative.Animated.add(new _reactNative.Animated.Value(containerWidth),_reactNative.Animated.multiply(new _reactNative.Animated.Value(-1),touchXValue));touchXValue.setValue(containerWidth);}else{touchXValue.setValue(0);}var translationX=dragX;if(drawerType==='front'){var startPositionX=_reactNative.Animated.add(touchX,_reactNative.Animated.multiply(new _reactNative.Animated.Value(-1),dragX));var dragOffsetFromOnStartPosition=startPositionX.interpolate({inputRange:[drawerWidth-1,drawerWidth,drawerWidth+1],outputRange:[0,0,1]});translationX=_reactNative.Animated.add(dragX,dragOffsetFromOnStartPosition);}_this._openValue=_reactNative.Animated.add(translationX,drawerTranslation).interpolate({inputRange:[0,drawerWidth],outputRange:[0,1],extrapolate:'clamp'});_this._onGestureEvent=_reactNative.Animated.event([{nativeEvent:{translationX:dragXValue,x:touchXValue}}],{useNativeDriver:props.useNativeAnimations});};_this._handleContainerLayout=function(_ref){var nativeEvent=_ref.nativeEvent;_this.setState({containerWidth:nativeEvent.layout.width});};_this._emitStateChanged=function(newState,drawerWillShow){_this.props.onDrawerStateChanged&&_this.props.onDrawerStateChanged(newState,drawerWillShow);};_this._openingHandlerStateChange=function(_ref2){var nativeEvent=_ref2.nativeEvent;if(nativeEvent.oldState===_reactNativeGestureHandler.State.ACTIVE){_this._handleRelease(nativeEvent);}else if(nativeEvent.state===_reactNativeGestureHandler.State.ACTIVE){_this._emitStateChanged(DRAGGING,false);if(_this.props.keyboardDismissMode==='on-drag'){_reactNative.Keyboard.dismiss();}if(_this.props.hideStatusBar){_reactNative.StatusBar.setHidden(true,_this.props.statusBarAnimation||'slide');}}};_this._onTapHandlerStateChange=function(_ref3){var nativeEvent=_ref3.nativeEvent;if(_this.state.drawerShown&&nativeEvent.oldState===_reactNativeGestureHandler.State.ACTIVE){_this.closeDrawer();}};_this._handleRelease=function(nativeEvent){var _this$props=_this.props,drawerWidth=_this$props.drawerWidth,drawerPosition=_this$props.drawerPosition,drawerType=_this$props.drawerType;var _this$state=_this.state,drawerShown=_this$state.drawerShown,containerWidth=_this$state.containerWidth;var dragX=nativeEvent.translationX,velocityX=nativeEvent.velocityX,touchX=nativeEvent.x;if(drawerPosition!=='left'){dragX=-dragX;touchX=containerWidth-touchX;velocityX=-velocityX;}var gestureStartX=touchX-dragX;var dragOffsetBasedOnStart=0;if(drawerType==='front'){dragOffsetBasedOnStart=gestureStartX>drawerWidth?gestureStartX-drawerWidth:0;}var startOffsetX=dragX+dragOffsetBasedOnStart+(drawerShown?drawerWidth:0);var projOffsetX=startOffsetX+DRAG_TOSS*velocityX;var shouldOpen=projOffsetX>drawerWidth/2;if(shouldOpen){_this._animateDrawer(startOffsetX,drawerWidth,velocityX);}else{_this._animateDrawer(startOffsetX,0,velocityX);}};_this._animateDrawer=function(fromValue,toValue,velocity){_this.state.dragX.setValue(0);_this.state.touchX.setValue(_this.props.drawerPosition==='left'?0:_this.state.containerWidth);if(fromValue!==undefined){_this.state.drawerTranslation.setValue(fromValue);}var willShow=toValue!==0;_this.setState({drawerShown:willShow});_this._emitStateChanged(SETTLING,willShow);if(_this.props.hideStatusBar){_reactNative.StatusBar.setHidden(willShow,_this.props.statusBarAnimation||'slide');}_reactNative.Animated.spring(_this.state.drawerTranslation,{velocity:velocity,bounciness:0,toValue:toValue,useNativeDriver:_this.props.useNativeAnimations}).start(function(_ref4){var finished=_ref4.finished;if(finished){_this._emitStateChanged(IDLE,willShow);if(willShow){_this.props.onDrawerOpen&&_this.props.onDrawerOpen();}else{_this.props.onDrawerClose&&_this.props.onDrawerClose();}}});};_this.openDrawer=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_this._animateDrawer(undefined,_this.props.drawerWidth,options.velocity?options.velocity:0);};_this.closeDrawer=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_this._animateDrawer(undefined,0,options.velocity?options.velocity:0);};_this._renderOverlay=function(){(0,_invariant.default)(_this._openValue,'should be set');var overlayOpacity=_this._openValue.interpolate({inputRange:[0,1],outputRange:[0,0.7],extrapolate:'clamp'});var dynamicOverlayStyles={opacity:overlayOpacity,backgroundColor:_this.props.overlayColor};return _react.default.createElement(_reactNativeGestureHandler.TapGestureHandler,{onHandlerStateChange:_this._onTapHandlerStateChange},_react.default.createElement(_reactNative.Animated.View,{pointerEvents:_this.state.drawerShown?'auto':'none',style:[styles.overlay,dynamicOverlayStyles]}));};_this._renderDrawer=function(){var drawerShown=_this.state.drawerShown;var _this$props2=_this.props,drawerBackgroundColor=_this$props2.drawerBackgroundColor,drawerWidth=_this$props2.drawerWidth,drawerPosition=_this$props2.drawerPosition,drawerType=_this$props2.drawerType,contentContainerStyle=_this$props2.contentContainerStyle;var fromLeft=drawerPosition==='left';var drawerSlide=drawerType!=='back';var containerSlide=drawerType!=='front';var dynamicDrawerStyles={backgroundColor:drawerBackgroundColor,width:drawerWidth};var openValue=_this._openValue;(0,_invariant.default)(openValue,'should be set');var containerStyles;if(containerSlide){var containerTranslateX=openValue.interpolate({inputRange:[0,1],outputRange:fromLeft?[0,drawerWidth]:[0,-drawerWidth],extrapolate:'clamp'});containerStyles={transform:[{translateX:containerTranslateX}]};}var drawerTranslateX=0;if(drawerSlide){var closedDrawerOffset=fromLeft?-drawerWidth:drawerWidth;drawerTranslateX=openValue.interpolate({inputRange:[0,1],outputRange:[closedDrawerOffset,0],extrapolate:'clamp'});}var drawerStyles={transform:[{translateX:drawerTranslateX}],flexDirection:fromLeft?'row':'row-reverse'};return _react.default.createElement(_reactNative.Animated.View,{style:styles.main,onLayout:_this._handleContainerLayout},_react.default.createElement(_reactNative.Animated.View,{style:[drawerType==='front'?styles.containerOnBack:styles.containerInFront,containerStyles,contentContainerStyle]},typeof _this.props.children==='function'?_this.props.children(_this._openValue):_this.props.children,_this._renderOverlay()),_react.default.createElement(_reactNative.Animated.View,{pointerEvents:\"box-none\",accessibilityViewIsModal:drawerShown,style:[styles.drawerContainer,drawerStyles]},_react.default.createElement(_reactNative.View,{style:[styles.drawer,dynamicDrawerStyles]},_this.props.renderNavigationView(_this._openValue))));};var _dragX=new _reactNative.Animated.Value(0);var _touchX=new _reactNative.Animated.Value(0);var _drawerTranslation=new _reactNative.Animated.Value(0);_this.state={dragX:_dragX,touchX:_touchX,drawerTranslation:_drawerTranslation,drawerShown:false,containerWidth:0};_this._updateAnimatedEvent(_props,_this.state);return _this;}(0,_createClass2.default)(DrawerLayout,[{key:\"componentWillUpdate\",value:function componentWillUpdate(props,state){if(this.props.drawerPosition!==props.drawerPosition||this.props.drawerWidth!==props.drawerWidth||this.props.drawerType!==props.drawerType||this.state.containerWidth!==state.containerWidth){this._updateAnimatedEvent(props,state);}}},{key:\"render\",value:function render(){var _this$state2=this.state,drawerShown=_this$state2.drawerShown,containerWidth=_this$state2.containerWidth;var _this$props3=this.props,drawerPosition=_this$props3.drawerPosition,drawerType=_this$props3.drawerType,edgeWidth=_this$props3.edgeWidth,minSwipeDistance=_this$props3.minSwipeDistance;var fromLeft=drawerPosition==='left';var gestureOrientation=(fromLeft?1:-1)*(drawerShown?-1:1);var hitSlop=fromLeft?{right:drawerShown?0:edgeWidth-containerWidth}:{left:drawerShown?0:edgeWidth-containerWidth};return _react.default.createElement(_reactNativeGestureHandler.PanGestureHandler,{hitSlop:hitSlop,minOffsetX:gestureOrientation*minSwipeDistance,onGestureEvent:this._onGestureEvent,onHandlerStateChange:this._openingHandlerStateChange},this._renderDrawer());}}]);return DrawerLayout;}(_react.Component);exports.default=DrawerLayout;DrawerLayout.defaultProps={drawerWidth:200,drawerPosition:'left',useNativeAnimations:true,drawerType:'front',edgeWidth:20,minSwipeDistance:3,overlayColor:'black'};DrawerLayout.positions={Left:'left',Right:'right'};var styles=_reactNative.StyleSheet.create({drawer:{flex:0},drawerContainer:(0,_objectSpread2.default)({},_reactNative.StyleSheet.absoluteFillObject,{zIndex:1001,flexDirection:'row'}),containerInFront:(0,_objectSpread2.default)({},_reactNative.StyleSheet.absoluteFillObject,{zIndex:1002}),containerOnBack:(0,_objectSpread2.default)({},_reactNative.StyleSheet.absoluteFillObject),main:{flex:1,zIndex:0,overflow:'hidden'},overlay:(0,_objectSpread2.default)({},_reactNative.StyleSheet.absoluteFillObject,{zIndex:1000})});","map":{"version":3,"sources":["/Users/ntareguy/Downloads/gwizamobile1/node_modules/react-native-gesture-handler/DrawerLayout.js"],"names":["DRAG_TOSS","IDLE","DRAGGING","SETTLING","DrawerLayout","props","context","_updateAnimatedEvent","state","drawerPosition","drawerWidth","drawerType","dragXValue","dragX","touchXValue","touchX","drawerTranslation","containerWidth","Animated","multiply","Value","add","setValue","translationX","startPositionX","dragOffsetFromOnStartPosition","interpolate","inputRange","outputRange","_openValue","extrapolate","_onGestureEvent","event","nativeEvent","x","useNativeDriver","useNativeAnimations","_handleContainerLayout","setState","layout","width","_emitStateChanged","newState","drawerWillShow","onDrawerStateChanged","_openingHandlerStateChange","oldState","State","ACTIVE","_handleRelease","keyboardDismissMode","Keyboard","dismiss","hideStatusBar","StatusBar","setHidden","statusBarAnimation","_onTapHandlerStateChange","drawerShown","closeDrawer","velocityX","gestureStartX","dragOffsetBasedOnStart","startOffsetX","projOffsetX","shouldOpen","_animateDrawer","fromValue","toValue","velocity","undefined","willShow","spring","bounciness","start","finished","onDrawerOpen","onDrawerClose","openDrawer","options","_renderOverlay","overlayOpacity","dynamicOverlayStyles","opacity","backgroundColor","overlayColor","styles","overlay","_renderDrawer","drawerBackgroundColor","contentContainerStyle","fromLeft","drawerSlide","containerSlide","dynamicDrawerStyles","openValue","containerStyles","containerTranslateX","transform","translateX","drawerTranslateX","closedDrawerOffset","drawerStyles","flexDirection","main","containerOnBack","containerInFront","children","drawerContainer","drawer","renderNavigationView","edgeWidth","minSwipeDistance","gestureOrientation","hitSlop","right","left","Component","defaultProps","positions","Left","Right","StyleSheet","create","flex","absoluteFillObject","zIndex","overflow"],"mappings":"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","sourcesContent":["// @flow\n\n// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport React, { Component } from 'react';\nimport { Animated, StyleSheet, View, Keyboard, StatusBar } from 'react-native';\nimport invariant from 'invariant';\nimport { AnimatedEvent } from 'react-native/Libraries/Animated/src/AnimatedEvent';\n\nimport {\n  PanGestureHandler,\n  TapGestureHandler,\n  State,\n} from 'react-native-gesture-handler';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE = 'Idle';\nconst DRAGGING = 'Dragging';\nconst SETTLING = 'Settling';\n\nexport type PropType = {\n  children: any,\n  drawerBackgroundColor?: string,\n  drawerPosition: 'left' | 'right',\n  drawerWidth: number,\n  keyboardDismissMode?: 'none' | 'on-drag',\n  onDrawerClose?: Function,\n  onDrawerOpen?: Function,\n  onDrawerStateChanged?: Function,\n  renderNavigationView: (progressAnimatedValue: any) => any,\n  useNativeAnimations: boolean,\n\n  // brand new properties\n  drawerType: 'front' | 'back' | 'slide',\n  edgeWidth: number,\n  minSwipeDistance: number,\n  hideStatusBar?: boolean,\n  statusBarAnimation?: 'slide' | 'none' | 'fade',\n  overlayColor: string,\n  contentContainerStyle?: any,\n\n  // Properties not yet supported\n  // onDrawerSlide?: Function\n  // drawerLockMode?: 'unlocked' | 'locked-closed' | 'locked-open',\n};\n\nexport type StateType = {\n  drawerShown: boolean,\n  dragX: any,\n  touchX: any,\n  drawerTranslation: any,\n  containerWidth: number,\n};\n\nexport type EventType = {\n  stopPropagation: Function,\n};\n\nexport type DrawerMovementOptionType = {\n  velocity?: number,\n};\n\nexport default class DrawerLayout extends Component<PropType, StateType> {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'black',\n  };\n\n  static positions = {\n    Left: 'left',\n    Right: 'right',\n  };\n  _openValue: ?Animated.Interpolation;\n  _onGestureEvent: ?AnimatedEvent;\n\n  constructor(props: PropType, context: any) {\n    super(props, context);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      drawerShown: false,\n      containerWidth: 0,\n    };\n\n    this._updateAnimatedEvent(props, this.state);\n  }\n\n  componentWillUpdate(props: PropType, state: StateType) {\n    if (\n      this.props.drawerPosition !== props.drawerPosition ||\n      this.props.drawerWidth !== props.drawerWidth ||\n      this.props.drawerType !== props.drawerType ||\n      this.state.containerWidth !== state.containerWidth\n    ) {\n      this._updateAnimatedEvent(props, state);\n    }\n  }\n\n  _updateAnimatedEvent = (props: PropType, state: StateType) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth,\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(new Animated.Value(-1), dragXValue);\n      touchX = Animated.add(\n        new Animated.Value(containerWidth),\n        Animated.multiply(new Animated.Value(-1), touchXValue)\n      );\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(\n        touchX,\n        Animated.multiply(new Animated.Value(-1), dragX)\n      );\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],\n        outputRange: [0, 0, 1],\n      });\n      translationX = Animated.add(dragX, dragOffsetFromOnStartPosition);\n    }\n\n    this._openValue = Animated.add(translationX, drawerTranslation).interpolate(\n      {\n        inputRange: [0, drawerWidth],\n        outputRange: [0, 1],\n        extrapolate: 'clamp',\n      }\n    );\n\n    this._onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\n      { useNativeDriver: props.useNativeAnimations }\n    );\n  };\n\n  _handleContainerLayout = ({ nativeEvent }) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  _emitStateChanged = (newState: string, drawerWillShow: boolean) => {\n    this.props.onDrawerStateChanged &&\n      this.props.onDrawerStateChanged(newState, drawerWillShow);\n  };\n\n  _openingHandlerStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this._handleRelease(nativeEvent);\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this._emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  _onTapHandlerStateChange = ({ nativeEvent }) => {\n    if (this.state.drawerShown && nativeEvent.oldState === State.ACTIVE) {\n      this.closeDrawer();\n    }\n  };\n\n  _handleRelease = nativeEvent => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { drawerShown, containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart =\n        gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;\n    }\n\n    const startOffsetX =\n      dragX + dragOffsetBasedOnStart + (drawerShown ? drawerWidth : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth / 2;\n\n    if (shouldOpen) {\n      this._animateDrawer(startOffsetX, drawerWidth, velocityX);\n    } else {\n      this._animateDrawer(startOffsetX, 0, velocityX);\n    }\n  };\n\n  _animateDrawer = (fromValue: ?number, toValue: number, velocity: number) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\n    );\n\n    if (fromValue !== undefined) {\n      this.state.drawerTranslation.setValue(fromValue);\n    }\n\n    const willShow = toValue !== 0;\n    this.setState({ drawerShown: willShow });\n    this._emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations,\n    }).start(({ finished }) => {\n      if (finished) {\n        this._emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen && this.props.onDrawerOpen();\n        } else {\n          this.props.onDrawerClose && this.props.onDrawerClose();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(\n      undefined,\n      this.props.drawerWidth,\n      options.velocity ? options.velocity : 0\n    );\n  };\n\n  closeDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\n  };\n\n  _renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this._openValue, 'should be set');\n    const overlayOpacity = this._openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 0.7],\n      extrapolate: 'clamp',\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor,\n    };\n    return (\n      <TapGestureHandler onHandlerStateChange={this._onTapHandlerStateChange}>\n        <Animated.View\n          pointerEvents={this.state.drawerShown ? 'auto' : 'none'}\n          style={[styles.overlay, dynamicOverlayStyles]}\n        />\n      </TapGestureHandler>\n    );\n  };\n\n  _renderDrawer = () => {\n    const { drawerShown } = this.state;\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      contentContainerStyle,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth,\n    };\n    const openValue = this._openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],\n        extrapolate: 'clamp',\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }],\n      };\n    }\n\n    let drawerTranslateX = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp',\n      });\n    }\n    const drawerStyles = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: fromLeft ? 'row' : 'row-reverse',\n    };\n\n    return (\n      <Animated.View style={styles.main} onLayout={this._handleContainerLayout}>\n        <Animated.View\n          style={[\n            drawerType === 'front'\n              ? styles.containerOnBack\n              : styles.containerInFront,\n            containerStyles,\n            contentContainerStyle,\n          ]}>\n          {typeof this.props.children === 'function'\n            ? this.props.children(this._openValue)\n            : this.props.children}\n          {this._renderOverlay()}\n        </Animated.View>\n        <Animated.View\n          pointerEvents=\"box-none\"\n          accessibilityViewIsModal={drawerShown}\n          style={[styles.drawerContainer, drawerStyles]}>\n          <View style={[styles.drawer, dynamicDrawerStyles]}>\n            {this.props.renderNavigationView(this._openValue)}\n          </View>\n        </Animated.View>\n      </Animated.View>\n    );\n  };\n\n  render() {\n    const { drawerShown, containerWidth } = this.state;\n\n    const {\n      drawerPosition,\n      drawerType,\n      edgeWidth,\n      minSwipeDistance,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation = (fromLeft ? 1 : -1) * (drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { right: drawerShown ? 0 : edgeWidth - containerWidth }\n      : { left: drawerShown ? 0 : edgeWidth - containerWidth };\n\n    return (\n      <PanGestureHandler\n        hitSlop={hitSlop}\n        minOffsetX={gestureOrientation * minSwipeDistance}\n        onGestureEvent={this._onGestureEvent}\n        onHandlerStateChange={this._openingHandlerStateChange}>\n        {this._renderDrawer()}\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawer: { flex: 0 },\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row',\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002,\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000,\n  },\n});\n"]},"metadata":{},"sourceType":"script"}