{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.__waitForEmptyLogQueueAsync=__waitForEmptyLogQueueAsync;exports.default=void 0;var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _expoConstants=require(\"expo-constants\");var _fbemitter=require(\"fbemitter\");var _invariant=_interopRequireDefault(require(\"invariant\"));var _uuidJs=_interopRequireDefault(require(\"uuid-js\"));var _LogSerialization=_interopRequireDefault(require(\"./LogSerialization\"));var _sessionId=_uuidJs.default.create().toString();var _logQueue=[];var _transportEventEmitter=new _fbemitter.EventEmitter();var _logCounter=0;var _isSendingLogs=false;var _completionPromise=null;var _resolveCompletion2=null;function enqueueRemoteLogAsync(level,additionalFields,data){var warning,lines,_ref,body,includesStack;return _regenerator.default.async(function enqueueRemoteLogAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!_isReactNativeWarning(data)){_context.next=8;break;}if(!(data.length===0)){_context.next=3;break;}throw new Error(\"Warnings must include log arguments\");case 3:warning=data[0];if(!(typeof warning!=='string')){_context.next=6;break;}throw new TypeError(\"The log argument for a warning must be a string\");case 6:lines=warning.split('\\n');if(lines.length>1&&/^\\s+in /.test(lines[1])){data[0]=lines[0];}case 8:_context.next=10;return _regenerator.default.awrap(_LogSerialization.default.serializeLogDataAsync(data,level));case 10:_ref=_context.sent;body=_ref.body;includesStack=_ref.includesStack;_logQueue.push((0,_objectSpread2.default)({count:_logCounter++,level:level,body:body,includesStack:includesStack},additionalFields));_sendRemoteLogsAsync().catch(function(error){setImmediate(function(){throw error;});});case 15:case\"end\":return _context.stop();}}},null,this);}function _sendRemoteLogsAsync(){var batch,logUrl;return _regenerator.default.async(function _sendRemoteLogsAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(_isSendingLogs||!_logQueue.length)){_context2.next=2;break;}return _context2.abrupt(\"return\");case 2:batch=_logQueue.splice(0);logUrl=_expoConstants.Constants.manifest.logUrl;(0,_invariant.default)(typeof logUrl==='string','The Expo project manifest must specify `logUrl`');_isSendingLogs=true;_context2.prev=6;_context2.next=9;return _regenerator.default.awrap(_sendNextLogBatchAsync(batch,logUrl));case 9:_context2.prev=9;_isSendingLogs=false;return _context2.finish(9);case 12:if(!_logQueue.length){_context2.next=16;break;}return _context2.abrupt(\"return\",_sendRemoteLogsAsync());case 16:if(_resolveCompletion2){_resolveCompletion2();}case 17:case\"end\":return _context2.stop();}}},null,this,[[6,,9,12]]);}function _sendNextLogBatchAsync(batch,logUrl){var response,success;return _regenerator.default.async(function _sendNextLogBatchAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;_context3.next=3;return _regenerator.default.awrap(fetch(logUrl,{method:'POST',headers:{'Content-Type':'application/json',Connection:'keep-alive','Proxy-Connection':'keep-alive',Accept:'application/json','Device-Id':_expoConstants.Constants.installationId,'Device-Name':_expoConstants.Constants.deviceName,'Session-Id':_sessionId},body:JSON.stringify(batch)}));case 3:response=_context3.sent;_context3.next=10;break;case 6:_context3.prev=6;_context3.t0=_context3[\"catch\"](0);_transportEventEmitter.emit('error',{error:_context3.t0});return _context3.abrupt(\"return\");case 10:success=response.status>=200&&response.status<300;if(!success){_transportEventEmitter.emit('error',{error:new Error(\"An HTTP error occurred when sending remote logs\"),response:response});}case 12:case\"end\":return _context3.stop();}}},null,this,[[0,6]]);}function addTransportErrorListener(listener){return _transportEventEmitter.addListener('error',listener);}function _isReactNativeWarning(data){var message=data[0];return data.length===1&&typeof message==='string'&&message.startsWith('Warning: ');}var _default={enqueueRemoteLogAsync:enqueueRemoteLogAsync,addTransportErrorListener:addTransportErrorListener};exports.default=_default;function __waitForEmptyLogQueueAsync(){if(_completionPromise){return _completionPromise;}if(!_isSendingLogs&&!_logQueue.length){return Promise.resolve();}_completionPromise=new Promise(function(resolve){_resolveCompletion2=function _resolveCompletion(){(0,_invariant.default)(!_isSendingLogs,\"Must not be sending logs at completion\");(0,_invariant.default)(!_logQueue.length,\"Log queue must be empty at completion\");_completionPromise=null;_resolveCompletion2=null;resolve();};});return _completionPromise;}","map":{"version":3,"sources":["../../src/logs/RemoteLogging.ts"],"names":[],"mappings":"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","sourcesContent":["import { Constants } from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport UUID from 'uuid-js';\n\nimport LogSerialization from './LogSerialization';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number;\n  level: LogLevel;\n  body: LogData[];\n  includesStack: boolean;\n  groupDepth?: number;\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean;\n  groupDepth?: number;\n  groupCollapsed?: boolean;\n};\n\nexport type LogData = string | LogErrorData;\nexport type LogErrorData = { message: string; stack: string };\n\ntype TransportErrorListener = (event: { error: Error; response?: Response }) => void;\n\nconst _sessionId = UUID.create().toString();\nconst _logQueue: LogEntry[] = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: Promise<void> | null = null;\nlet _resolveCompletion: (() => void) | null = null;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: unknown[]\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n    const warning = data[0];\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  let { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch(error => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  let batch = _logQueue.splice(0);\n\n  let { logUrl } = Constants.manifest;\n  invariant(typeof logUrl === 'string', 'The Expo project manifest must specify `logUrl`');\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: LogEntry[], logUrl: string): Promise<void> {\n  let response;\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Connection: 'keep-alive',\n        'Proxy-Connection': 'keep-alive',\n        Accept: 'application/json',\n        'Device-Id': Constants.installationId,\n        'Device-Name': Constants.deviceName,\n        'Session-Id': _sessionId,\n      },\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  let success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: unknown[]): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  let message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}