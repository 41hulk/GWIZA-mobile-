{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _fbemitter=require(\"fbemitter\");var _warning=_interopRequireDefault(require(\"fbjs/lib/warning\"));var _invariant=_interopRequireDefault(require(\"invariant\"));var _reactNative=require(\"react-native\");var ExponentNotifications=_reactNative.NativeModules.ExponentNotifications;var _emitter;var _initialNotification;function _maybeInitEmitter(){if(!_emitter){_emitter=new _fbemitter.EventEmitter();_reactNative.DeviceEventEmitter.addListener('Exponent.notification',_emitNotification);}}function _emitNotification(notification){if(typeof notification==='string'){notification=JSON.parse(notification);}notification=(0,_objectSpread2.default)({},notification);if(typeof notification.data==='string'){try{notification.data=JSON.parse(notification.data);}catch(e){}}_emitter.emit('notification',notification);}function _processNotification(notification){notification=(0,_extends2.default)({},notification);if(!notification.data){notification.data={};}if(notification.hasOwnProperty('count')){delete notification.count;}if(_reactNative.Platform.OS==='ios'){if(notification.android){delete notification.android;}if(notification.ios){notification=(0,_extends2.default)(notification,notification.ios);delete notification.ios;}}if(_reactNative.Platform.OS==='android'){if(notification.ios){delete notification.ios;}if(notification.android){notification=(0,_extends2.default)(notification,notification.android);delete notification.android;}}return notification;}function _validateNotification(notification){if(_reactNative.Platform.OS==='ios'){(0,_invariant.default)(!!notification.title&&!!notification.body,'Local notifications on iOS require both a title and a body');}else if(_reactNative.Platform.OS==='android'){(0,_invariant.default)(!!notification.title,'Local notifications on Android require a title');}}var ASYNC_STORAGE_PREFIX='__expo_internal_channel_';var IS_USING_NEW_BINARY=typeof ExponentNotifications.createChannel==='function';function _legacyReadChannel(id){var channelString;return _regenerator.default.async(function _legacyReadChannel$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return _regenerator.default.awrap(_reactNative.AsyncStorage.getItem(\"\"+ASYNC_STORAGE_PREFIX+id));case 3:channelString=_context.sent;if(!channelString){_context.next=6;break;}return _context.abrupt(\"return\",JSON.parse(channelString));case 6:_context.next=10;break;case 8:_context.prev=8;_context.t0=_context[\"catch\"](0);case 10:return _context.abrupt(\"return\",null);case 11:case\"end\":return _context.stop();}}},null,this,[[0,8]]);}function _legacyDeleteChannel(id){return _reactNative.AsyncStorage.removeItem(\"\"+ASYNC_STORAGE_PREFIX+id);}if(_reactNative.Platform.OS==='android'){_reactNative.AsyncStorage.clear=function _callee(callback){var keys,result,filteredKeys;return _regenerator.default.async(function _callee$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.prev=0;_context2.next=3;return _regenerator.default.awrap(_reactNative.AsyncStorage.getAllKeys());case 3:keys=_context2.sent;result=null;if(!(keys&&keys.length)){_context2.next=9;break;}filteredKeys=keys.filter(function(key){return!key.startsWith(ASYNC_STORAGE_PREFIX);});_context2.next=9;return _regenerator.default.awrap(_reactNative.AsyncStorage.multiRemove(filteredKeys));case 9:callback&&callback();_context2.next=16;break;case 12:_context2.prev=12;_context2.t0=_context2[\"catch\"](0);callback&&callback(_context2.t0);throw _context2.t0;case 16:case\"end\":return _context2.stop();}}},null,this,[[0,12]]);};}function _legacySaveChannel(id,channel){return _reactNative.AsyncStorage.setItem(\"\"+ASYNC_STORAGE_PREFIX+id,JSON.stringify(channel));}var _default={_setInitialNotification:function _setInitialNotification(notification){_initialNotification=notification;},getExpoPushTokenAsync:function getExpoPushTokenAsync(){return ExponentNotifications.getExponentPushTokenAsync();},getDevicePushTokenAsync:function getDevicePushTokenAsync(config){return ExponentNotifications.getDevicePushTokenAsync(config||{});},createChannelAndroidAsync:function createChannelAndroidAsync(id,channel){if(_reactNative.Platform.OS==='ios'){console.warn('createChannelAndroidAsync(...) has no effect on iOS');return Promise.resolve();}if(!IS_USING_NEW_BINARY){return _legacySaveChannel(id,channel);}return ExponentNotifications.createChannel(id,channel);},deleteChannelAndroidAsync:function deleteChannelAndroidAsync(id){if(_reactNative.Platform.OS==='ios'){console.warn('deleteChannelAndroidAsync(...) has no effect on iOS');return Promise.resolve();}if(!IS_USING_NEW_BINARY){return Promise.resolve();}return ExponentNotifications.deleteChannel(id);},presentLocalNotificationAsync:function presentLocalNotificationAsync(notification){var nativeNotification,_channel;return _regenerator.default.async(function presentLocalNotificationAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_validateNotification(notification);nativeNotification=_processNotification(notification);if(!(_reactNative.Platform.OS==='ios')){_context3.next=6;break;}return _context3.abrupt(\"return\",ExponentNotifications.presentLocalNotification(nativeNotification));case 6:if(!nativeNotification.channelId){_context3.next=10;break;}_context3.next=9;return _regenerator.default.awrap(_legacyReadChannel(nativeNotification.channelId));case 9:_channel=_context3.sent;case 10:if(!IS_USING_NEW_BINARY){_context3.next=15;break;}_legacyDeleteChannel(nativeNotification.channelId);return _context3.abrupt(\"return\",ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification,_channel));case 15:if(_channel){nativeNotification.sound=_channel.sound;nativeNotification.priority=_channel.priority;nativeNotification.vibrate=_channel.vibrate;}return _context3.abrupt(\"return\",ExponentNotifications.presentLocalNotification(nativeNotification));case 17:case\"end\":return _context3.stop();}}},null,this);},scheduleLocalNotificationAsync:function scheduleLocalNotificationAsync(notification){var options,now,nativeNotification,timeAsDateObj,validOptions,_channel2,_args4=arguments;return _regenerator.default.async(function scheduleLocalNotificationAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:options=_args4.length>1&&_args4[1]!==undefined?_args4[1]:{};now=Date.now();_validateNotification(notification);nativeNotification=_processNotification(notification);if(!options.time){_context4.next=11;break;}timeAsDateObj=null;if(options.time&&typeof options.time==='number'){timeAsDateObj=new Date(options.time);if(timeAsDateObj.toString()==='Invalid Date'){timeAsDateObj=null;}}else if(options.time&&options.time instanceof Date){timeAsDateObj=options.time;}if(timeAsDateObj){_context4.next=9;break;}throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");case 9:(0,_warning.default)(timeAsDateObj.getTime()>=now,\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");if(_reactNative.Platform.OS==='ios'){options=(0,_objectSpread2.default)({},options,{time:timeAsDateObj.getTime()});}else{options=(0,_objectSpread2.default)({},options,{time:timeAsDateObj});}case 11:if(!(options.intervalMs!=null&&options.repeat!=null)){_context4.next=13;break;}throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");case 13:if(!(options.repeat!=null)){_context4.next=17;break;}validOptions=new Set(['minute','hour','day','week','month','year']);if(validOptions.has(options.repeat)){_context4.next=17;break;}throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");case 17:if(!(options.intervalMs!=null)){_context4.next=22;break;}if(!(_reactNative.Platform.OS==='ios')){_context4.next=20;break;}throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");case 20:if(!(options.intervalMs<=0||!Number.isInteger(options.intervalMs))){_context4.next=22;break;}throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");case 22:if(!(_reactNative.Platform.OS==='ios')){_context4.next=26;break;}return _context4.abrupt(\"return\",ExponentNotifications.scheduleLocalNotification(nativeNotification,options));case 26:if(!nativeNotification.channelId){_context4.next=30;break;}_context4.next=29;return _regenerator.default.awrap(_legacyReadChannel(nativeNotification.channelId));case 29:_channel2=_context4.sent;case 30:if(!IS_USING_NEW_BINARY){_context4.next=35;break;}_legacyDeleteChannel(nativeNotification.channelId);return _context4.abrupt(\"return\",ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification,options,_channel2));case 35:if(_channel2){nativeNotification.sound=_channel2.sound;nativeNotification.priority=_channel2.priority;nativeNotification.vibrate=_channel2.vibrate;}return _context4.abrupt(\"return\",ExponentNotifications.scheduleLocalNotification(nativeNotification,options));case 37:case\"end\":return _context4.stop();}}},null,this);},dismissNotificationAsync:function dismissNotificationAsync(notificationId){return _regenerator.default.async(function dismissNotificationAsync$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:if(!(_reactNative.Platform.OS==='android')){_context5.next=4;break;}return _context5.abrupt(\"return\",ExponentNotifications.dismissNotification(notificationId));case 4:throw new Error('Dismissing notifications is not supported on iOS');case 5:case\"end\":return _context5.stop();}}},null,this);},dismissAllNotificationsAsync:function dismissAllNotificationsAsync(){return _regenerator.default.async(function dismissAllNotificationsAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:if(!(_reactNative.Platform.OS==='android')){_context6.next=4;break;}return _context6.abrupt(\"return\",ExponentNotifications.dismissAllNotifications());case 4:throw new Error('Dismissing notifications is not supported on iOS');case 5:case\"end\":return _context6.stop();}}},null,this);},cancelScheduledNotificationAsync:function cancelScheduledNotificationAsync(notificationId){return ExponentNotifications.cancelScheduledNotification(notificationId);},cancelAllScheduledNotificationsAsync:function cancelAllScheduledNotificationsAsync(){return ExponentNotifications.cancelAllScheduledNotifications();},addListener:function addListener(listener){_maybeInitEmitter();if(_initialNotification){var initialNotification=_initialNotification;_initialNotification=null;setTimeout(function(){_emitNotification(initialNotification);},0);}return _emitter.addListener('notification',listener);},getBadgeNumberAsync:function getBadgeNumberAsync(){return _regenerator.default.async(function getBadgeNumberAsync$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:if(ExponentNotifications.getBadgeNumberAsync){_context7.next=2;break;}return _context7.abrupt(\"return\",0);case 2:return _context7.abrupt(\"return\",ExponentNotifications.getBadgeNumberAsync());case 3:case\"end\":return _context7.stop();}}},null,this);},setBadgeNumberAsync:function setBadgeNumberAsync(number){return _regenerator.default.async(function setBadgeNumberAsync$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:if(ExponentNotifications.setBadgeNumberAsync){_context8.next=2;break;}return _context8.abrupt(\"return\");case 2:return _context8.abrupt(\"return\",ExponentNotifications.setBadgeNumberAsync(number));case 3:case\"end\":return _context8.stop();}}},null,this);}};exports.default=_default;","map":{"version":3,"sources":["../src/Notifications.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, EventSubscription } from 'fbemitter';\nimport warning from 'fbjs/lib/warning';\nimport invariant from 'invariant';\nimport { AsyncStorage, DeviceEventEmitter, NativeModules, Platform } from 'react-native';\n\nconst { ExponentNotifications } = NativeModules;\n\ntype Notification = {\n  origin: 'selected' | 'received';\n  data: any;\n  remote: boolean;\n  isMultiple: boolean;\n};\n\ntype LocalNotification = {\n  title: string;\n  // How should we deal with body being required on iOS but not on Android?\n  body?: string;\n  data?: any;\n  ios?: {\n    sound?: boolean;\n  };\n  android?: {\n    channelId?: string;\n    icon?: string;\n    color?: string;\n    sticky?: boolean;\n    link?: string;\n    // DEPRECATED:\n    sound?: boolean;\n    vibrate?: boolean | number[];\n    priority: string;\n  };\n};\n\ntype Channel = {\n  name: string;\n  description?: string;\n  priority?: string;\n  sound?: boolean;\n  vibrate?: boolean | number[];\n  badge?: boolean;\n};\n\n// Android assigns unique number to each notification natively.\n// Since that's not supported on iOS, we generate an unique string.\ntype LocalNotificationId = string | number;\n\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    DeviceEventEmitter.addListener('Exponent.notification', _emitNotification);\n  }\n}\n\nfunction _emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nlet ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nlet IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    let channelString = await AsyncStorage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return AsyncStorage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = async function(callback?: (error?: Error) => void): Promise<void> {\n    try {\n      let keys = await AsyncStorage.getAllKeys();\n      let result = null;\n      if (keys && keys.length) {\n        let filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await AsyncStorage.multiRemove(filteredKeys);\n      }\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return AsyncStorage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: (config: {\n    gcmSenderId?: string;\n  }): Promise<{ type: string; data: string }> =>\n    ExponentNotifications.getDevicePushTokenAsync(config || {}),\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS === 'ios') {\n      console.warn('createChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS === 'ios') {\n      console.warn('deleteChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    if (Platform.OS === 'ios') {\n      return ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(\n          nativeNotification,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj: Date | null = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      warning(\n        timeAsDateObj.getTime() >= now,\n        `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n      );\n\n      // If iOS, pass time as milliseconds\n      if (Platform.OS === 'ios') {\n        options = {\n          ...options,\n          time: timeAsDateObj.getTime(),\n        };\n      } else {\n        options = {\n          ...options,\n          time: timeAsDateObj,\n        };\n      }\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS === 'ios') {\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          nativeNotification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissNotification(notificationId);\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissAllNotifications();\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    return ExponentNotifications.cancelScheduledNotification(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotifications();\n  },\n\n  /* Primary public api */\n  addListener(listener: Function): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        _emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      return;\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}