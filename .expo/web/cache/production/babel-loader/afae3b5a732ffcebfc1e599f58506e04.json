{"ast":null,"code":"'use strict';var _classCallCheck=require(\"@babel/runtime/helpers/classCallCheck\");var _createClass=require(\"@babel/runtime/helpers/createClass\");var Blob=function(){function Blob(){var parts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var options=arguments.length>1?arguments[1]:undefined;_classCallCheck(this,Blob);var BlobManager=require(\"./BlobManager\");this.data=BlobManager.createFromParts(parts,options).data;}_createClass(Blob,[{key:\"slice\",value:function slice(start,end){var BlobManager=require(\"./BlobManager\");var _this$data=this.data,offset=_this$data.offset,size=_this$data.size;if(typeof start==='number'){if(start>size){start=size;}offset+=start;size-=start;if(typeof end==='number'){if(end<0){end=this.size+end;}size=end-start;}}return BlobManager.createFromOptions({blobId:this.data.blobId,offset:offset,size:size});}},{key:\"close\",value:function close(){var BlobManager=require(\"./BlobManager\");BlobManager.release(this.data.blobId);this.data=null;}},{key:\"data\",set:function set(data){this._data=data;},get:function get(){if(!this._data){throw new Error('Blob has been closed and is no longer available');}return this._data;}},{key:\"size\",get:function get(){return this.data.size;}},{key:\"type\",get:function get(){return this.data.type||'';}}]);return Blob;}();module.exports=Blob;","map":{"version":3,"sources":["/Users/ntareguy/Downloads/gwizamobile1/node_modules/react-native/Libraries/Blob/Blob.js"],"names":["Blob","parts","options","BlobManager","require","data","createFromParts","start","end","offset","size","createFromOptions","blobId","release","_data","Error","type","module","exports"],"mappings":"AAUA,a,uIAyCMA,CAAAA,I,YAQJ,eAAqE,IAAzDC,CAAAA,KAAyD,2DAA3B,EAA2B,IAAvBC,CAAAA,OAAuB,sEACnE,GAAMC,CAAAA,WAAW,CAAGC,OAAO,iBAA3B,CACA,KAAKC,IAAL,CAAYF,WAAW,CAACG,eAAZ,CAA4BL,KAA5B,CAAmCC,OAAnC,EAA4CG,IAAxD,CACD,C,qDAmBKE,K,CAAgBC,G,CAAoB,CACxC,GAAML,CAAAA,WAAW,CAAGC,OAAO,iBAA3B,CADwC,eAEnB,KAAKC,IAFc,CAEnCI,MAFmC,YAEnCA,MAFmC,CAE3BC,IAF2B,YAE3BA,IAF2B,CAIxC,GAAI,MAAOH,CAAAA,KAAP,GAAiB,QAArB,CAA+B,CAC7B,GAAIA,KAAK,CAAGG,IAAZ,CAAkB,CAChBH,KAAK,CAAGG,IAAR,CACD,CACDD,MAAM,EAAIF,KAAV,CACAG,IAAI,EAAIH,KAAR,CAEA,GAAI,MAAOC,CAAAA,GAAP,GAAe,QAAnB,CAA6B,CAC3B,GAAIA,GAAG,CAAG,CAAV,CAAa,CACXA,GAAG,CAAG,KAAKE,IAAL,CAAYF,GAAlB,CACD,CACDE,IAAI,CAAGF,GAAG,CAAGD,KAAb,CACD,CACF,CACD,MAAOJ,CAAAA,WAAW,CAACQ,iBAAZ,CAA8B,CACnCC,MAAM,CAAE,KAAKP,IAAL,CAAUO,MADiB,CAEnCH,MAAM,CAANA,MAFmC,CAGnCC,IAAI,CAAJA,IAHmC,CAA9B,CAAP,CAKD,C,qCAcO,CACN,GAAMP,CAAAA,WAAW,CAAGC,OAAO,iBAA3B,CACAD,WAAW,CAACU,OAAZ,CAAoB,KAAKR,IAAL,CAAUO,MAA9B,EACA,KAAKP,IAAL,CAAY,IAAZ,CACD,C,+BArDQA,I,CAAiB,CACxB,KAAKS,KAAL,CAAaT,IAAb,CACD,C,mBAEoB,CACnB,GAAI,CAAC,KAAKS,KAAV,CAAiB,CACf,KAAM,IAAIC,CAAAA,KAAJ,CAAU,iDAAV,CAAN,CACD,CAED,MAAO,MAAKD,KAAZ,CACD,C,gCAgDkB,CACjB,MAAO,MAAKT,IAAL,CAAUK,IAAjB,CACD,C,gCAMkB,CACjB,MAAO,MAAKL,IAAL,CAAUW,IAAV,EAAkB,EAAzB,CACD,C,oBAGHC,MAAM,CAACC,OAAP,CAAiBlB,IAAjB","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {BlobData, BlobOptions} from './BlobTypes';\n\n/**\n * Opaque JS representation of some binary data in native.\n *\n * The API is modeled after the W3C Blob API, with one caveat\n * regarding explicit deallocation. Refer to the `close()`\n * method for further details.\n *\n * Example usage in a React component:\n *\n *   class WebSocketImage extends React.Component {\n *      state = {blob: null};\n *      componentDidMount() {\n *        let ws = this.ws = new WebSocket(...);\n *        ws.binaryType = 'blob';\n *        ws.onmessage = (event) => {\n *          if (this.state.blob) {\n *            this.state.blob.close();\n *          }\n *          this.setState({blob: event.data});\n *        };\n *      }\n *      componentUnmount() {\n *        if (this.state.blob) {\n *          this.state.blob.close();\n *        }\n *        this.ws.close();\n *      }\n *      render() {\n *        if (!this.state.blob) {\n *          return <View />;\n *        }\n *        return <Image source={{uri: URL.createObjectURL(this.state.blob)}} />;\n *      }\n *   }\n *\n * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Blob\n */\nclass Blob {\n  _data: ?BlobData;\n\n  /**\n   * Constructor for JS consumers.\n   * Currently we only support creating Blobs from other Blobs.\n   * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob\n   */\n  constructor(parts: Array<Blob | string> = [], options?: BlobOptions) {\n    const BlobManager = require('./BlobManager');\n    this.data = BlobManager.createFromParts(parts, options).data;\n  }\n\n  /*\n   * This method is used to create a new Blob object containing\n   * the data in the specified range of bytes of the source Blob.\n   * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Blob/slice\n   */\n  set data(data: ?BlobData) {\n    this._data = data;\n  }\n\n  get data(): BlobData {\n    if (!this._data) {\n      throw new Error('Blob has been closed and is no longer available');\n    }\n\n    return this._data;\n  }\n\n  slice(start?: number, end?: number): Blob {\n    const BlobManager = require('./BlobManager');\n    let {offset, size} = this.data;\n\n    if (typeof start === 'number') {\n      if (start > size) {\n        start = size;\n      }\n      offset += start;\n      size -= start;\n\n      if (typeof end === 'number') {\n        if (end < 0) {\n          end = this.size + end;\n        }\n        size = end - start;\n      }\n    }\n    return BlobManager.createFromOptions({\n      blobId: this.data.blobId,\n      offset,\n      size,\n    });\n  }\n\n  /**\n   * This method is in the standard, but not actually implemented by\n   * any browsers at this point. It's important for how Blobs work in\n   * React Native, however, since we cannot de-allocate resources automatically,\n   * so consumers need to explicitly de-allocate them.\n   *\n   * Note that the semantics around Blobs created via `blob.slice()`\n   * and `new Blob([blob])` are different. `blob.slice()` creates a\n   * new *view* onto the same binary data, so calling `close()` on any\n   * of those views is enough to deallocate the data, whereas\n   * `new Blob([blob, ...])` actually copies the data in memory.\n   */\n  close() {\n    const BlobManager = require('./BlobManager');\n    BlobManager.release(this.data.blobId);\n    this.data = null;\n  }\n\n  /**\n   * Size of the data contained in the Blob object, in bytes.\n   */\n  get size(): number {\n    return this.data.size;\n  }\n\n  /*\n   * String indicating the MIME type of the data contained in the Blob.\n   * If the type is unknown, this string is empty.\n   */\n  get type(): string {\n    return this.data.type || '';\n  }\n}\n\nmodule.exports = Blob;\n"]},"metadata":{},"sourceType":"script"}