{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.props2transform=props2transform;exports.default=_default;var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _Matrix2D=_interopRequireDefault(require(\"../Matrix2D\"));var _pegjs=_interopRequireDefault(require(\"pegjs\"));var _lodash=_interopRequireDefault(require(\"lodash\"));var pooledMatrix=new _Matrix2D.default();function transformToMatrix(props,transform){pooledMatrix.reset();appendTransform(props);if(transform){appendTransform(transform);}return pooledMatrix.toArray();}var transformParser=_pegjs.default.generate(\"\\n{\\n    var deg2rad = Math.PI / 180;\\n\\n    /*\\n     \\u2554\\u2550        \\u2550\\u2557   \\u2554\\u2550        \\u2550\\u2557   \\u2554\\u2550     \\u2550\\u2557\\n     \\u2551 al cl el \\u2551   \\u2551 ar cr er \\u2551   \\u2551 a c e \\u2551\\n     \\u2551 bl dl fl \\u2551 * \\u2551 br dr fr \\u2551 = \\u2551 b d f \\u2551\\n     \\u2551 0  0  1  \\u2551   \\u2551 0  0  1  \\u2551   \\u2551 0 0 1 \\u2551\\n     \\u255A\\u2550        \\u2550\\u255D   \\u255A\\u2550        \\u2550\\u255D   \\u255A\\u2550     \\u2550\\u255D\\n    */\\n    function multiply_matrices(l, r) {\\n        var [al, cl, el, bl, dl, fl] = l;\\n        var [ar, cr, er, br, dr, fr] = r;\\n\\n        var a = al * ar + cl * br;\\n        var c = al * cr + cl * dr;\\n        var e = al * er + cl * fr + el;\\n        var b = bl * ar + dl * br;\\n        var d = bl * cr + dl * dr;\\n        var f = bl * er + dl * fr + fl;\\n\\n        return [a, c, e, b, d, f];\\n    }\\n}\\n\\ntransformList\\n    = wsp* ts:transforms? wsp* { return ts; }\\n\\ntransforms\\n    = t:transform commaWsp* ts:transforms\\n    {\\n        return multiply_matrices(t, ts);\\n    }\\n    / t:transform\\n\\ntransform\\n    = matrix\\n    / translate\\n    / scale\\n    / rotate\\n    / skewX\\n    / skewY\\n\\nmatrix\\n    = \\\"matrix\\\" wsp* \\\"(\\\" wsp*\\n        a:number commaWsp\\n        b:number commaWsp\\n        c:number commaWsp\\n        d:number commaWsp\\n        e:number commaWsp\\n        f:number wsp* \\\")\\\"\\n    {\\n        return [\\n            a, c, e,\\n            b, d, f\\n        ];\\n    }\\n\\ntranslate\\n    = \\\"translate\\\" wsp* \\\"(\\\" wsp* tx:number ty:commaWspNumber? wsp* \\\")\\\"\\n    {\\n        return [\\n            1, 0, tx,\\n            0, 1, ty || 0\\n        ];\\n    }\\n\\nscale\\n    = \\\"scale\\\" wsp* \\\"(\\\" wsp* sx:number sy:commaWspNumber? wsp* \\\")\\\"\\n    {\\n        return [\\n            sx, 0,                     0,\\n            0,  sy === null ? sx : sy, 0\\n        ];\\n    }\\n\\nrotate\\n    = \\\"rotate\\\" wsp* \\\"(\\\" wsp* angle:number c:commaWspTwoNumbers? wsp* \\\")\\\"\\n    {\\n        var cos = Math.cos(deg2rad * angle);\\n        var sin = Math.sin(deg2rad * angle);\\n        if (c !== null) {\\n            var [x, y] = c;\\n            return [\\n                cos, -sin, cos * -x + -sin * -y + x,\\n                sin,  cos, sin * -x +  cos * -y + y\\n            ];\\n        }\\n        return [\\n            cos, -sin, 0,\\n            sin,  cos, 0\\n        ];\\n    }\\n\\nskewX\\n    = \\\"skewX\\\" wsp* \\\"(\\\" wsp* angle:number wsp* \\\")\\\"\\n    {\\n        return [\\n            1, Math.tan(deg2rad * angle), 0,\\n            0, 1,                         0\\n        ];\\n    }\\n\\nskewY\\n    = \\\"skewY\\\" wsp* \\\"(\\\" wsp* angle:number wsp* \\\")\\\"\\n    {\\n        return [\\n            1,                         0, 0,\\n            Math.tan(deg2rad * angle), 1, 0\\n        ];\\n    }\\n\\nnumber\\n    = f:(sign? floatingPointConstant) { return parseFloat(f.join(\\\"\\\")); }\\n    / i:(sign? integerConstant) { return parseInt(i.join(\\\"\\\")); }\\n\\ncommaWspNumber\\n    = commaWsp n:number { return n; }\\n\\ncommaWspTwoNumbers\\n    = commaWsp n1:number commaWsp n2:number { return [n1, n2]; }\\n\\ncommaWsp\\n    = (wsp+ comma? wsp*) / (comma wsp*)\\n\\ncomma\\n    = \\\",\\\"\\n\\nintegerConstant\\n    = ds:digitSequence { return ds.join(\\\"\\\"); }\\n\\nfloatingPointConstant\\n    = f:(fractionalConstant exponent?) { return f.join(\\\"\\\"); }\\n    / d:(digitSequence exponent) { return d.join(\\\"\\\"); }\\n\\nfractionalConstant \\\"fractionalConstant\\\"\\n    = d1:digitSequence? \\\".\\\" d2:digitSequence { return [d1 ? d1.join(\\\"\\\") : null, \\\".\\\", d2.join(\\\"\\\")].join(\\\"\\\"); }\\n    / d:digitSequence \\\".\\\" { return d.join(\\\"\\\"); }\\n\\nexponent\\n    =  e:([eE] sign? digitSequence) { return [e[0], e[1], e[2].join(\\\"\\\")].join(\\\"\\\"); }\\n\\nsign\\n    = [+-]\\n\\ndigitSequence\\n    = digit+\\n\\ndigit\\n    = [0-9]\\n\\nwsp\\n    = [\\\\u0020\\\\u0009\\\\u000D\\\\u000A]\\n\");function appendTransform(transform){if(transform){if(typeof transform===\"string\"){try{var _transformParser$pars=transformParser.parse(transform),_transformParser$pars2=(0,_slicedToArray2.default)(_transformParser$pars,6),a=_transformParser$pars2[0],c=_transformParser$pars2[1],e=_transformParser$pars2[2],b=_transformParser$pars2[3],d=_transformParser$pars2[4],f=_transformParser$pars2[5];pooledMatrix.append.apply(pooledMatrix,[a,b,c,d,e,f]);}catch(e){console.error(e);}}else{pooledMatrix.appendTransform(transform.x+transform.originX,transform.y+transform.originY,transform.scaleX,transform.scaleY,transform.rotation,transform.skewX,transform.skewY,transform.originX,transform.originY);}}}function universal2axis(universal,axisX,axisY,defaultValue){var coords=[];var x;var y;if(_lodash.default.isString(universal)){coords=universal.split(/\\s*,\\s*/);if(coords.length===2){x=+coords[0];y=+coords[1];}else if(coords.length===1){x=y=+coords[0];}}else if(_lodash.default.isNumber(universal)){x=y=universal;}axisX=+axisX;if(!isNaN(axisX)){x=axisX;}axisY=+axisY;if(!isNaN(axisY)){y=axisY;}return[x||defaultValue||0,y||defaultValue||0];}function props2transform(props){if(props&&typeof props===\"string\"){return props;}var _universal2axis=universal2axis(props.origin,props.originX,props.originY),_universal2axis2=(0,_slicedToArray2.default)(_universal2axis,2),originX=_universal2axis2[0],originY=_universal2axis2[1];var _universal2axis3=universal2axis(props.scale,props.scaleX,props.scaleY,1),_universal2axis4=(0,_slicedToArray2.default)(_universal2axis3,2),scaleX=_universal2axis4[0],scaleY=_universal2axis4[1];var _universal2axis5=universal2axis(props.skew,props.skewX,props.skewY),_universal2axis6=(0,_slicedToArray2.default)(_universal2axis5,2),skewX=_universal2axis6[0],skewY=_universal2axis6[1];var _universal2axis7=universal2axis(props.translate,_lodash.default.isNil(props.translateX)?props.x||0:props.translateX,_lodash.default.isNil(props.translateY)?props.y||0:props.translateY),_universal2axis8=(0,_slicedToArray2.default)(_universal2axis7,2),translateX=_universal2axis8[0],translateY=_universal2axis8[1];return{rotation:+props.rotation||0,scaleX:scaleX,scaleY:scaleY,originX:originX,originY:originY,skewX:skewX,skewY:skewY,x:translateX,y:translateY};}function _default(props){return transformToMatrix(props2transform(props),props.transform?props2transform(props.transform):null);}","map":{"version":3,"sources":["/Users/ntareguy/Downloads/gwizamobile1/node_modules/expo/node_modules/react-native-svg/lib/extract/extractTransform.js"],"names":["pooledMatrix","Matrix2D","transformToMatrix","props","transform","reset","appendTransform","toArray","transformParser","peg","generate","parse","a","c","e","b","d","f","append","console","error","x","originX","y","originY","scaleX","scaleY","rotation","skewX","skewY","universal2axis","universal","axisX","axisY","defaultValue","coords","_","isString","split","length","isNumber","isNaN","props2transform","origin","scale","skew","translate","isNil","translateX","translateY"],"mappings":"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","sourcesContent":["import Matrix2D from \"../Matrix2D\";\nimport peg from \"pegjs\";\nimport _ from \"lodash\";\n\nconst pooledMatrix = new Matrix2D();\n\nfunction transformToMatrix(props, transform) {\n    pooledMatrix.reset();\n    appendTransform(props);\n\n    if (transform) {\n        appendTransform(transform);\n    }\n\n    return pooledMatrix.toArray();\n}\n\nconst transformParser = peg.generate(`\n{\n    var deg2rad = Math.PI / 180;\n\n    /*\n     ╔═        ═╗   ╔═        ═╗   ╔═     ═╗\n     ║ al cl el ║   ║ ar cr er ║   ║ a c e ║\n     ║ bl dl fl ║ * ║ br dr fr ║ = ║ b d f ║\n     ║ 0  0  1  ║   ║ 0  0  1  ║   ║ 0 0 1 ║\n     ╚═        ═╝   ╚═        ═╝   ╚═     ═╝\n    */\n    function multiply_matrices(l, r) {\n        var [al, cl, el, bl, dl, fl] = l;\n        var [ar, cr, er, br, dr, fr] = r;\n\n        var a = al * ar + cl * br;\n        var c = al * cr + cl * dr;\n        var e = al * er + cl * fr + el;\n        var b = bl * ar + dl * br;\n        var d = bl * cr + dl * dr;\n        var f = bl * er + dl * fr + fl;\n\n        return [a, c, e, b, d, f];\n    }\n}\n\ntransformList\n    = wsp* ts:transforms? wsp* { return ts; }\n\ntransforms\n    = t:transform commaWsp* ts:transforms\n    {\n        return multiply_matrices(t, ts);\n    }\n    / t:transform\n\ntransform\n    = matrix\n    / translate\n    / scale\n    / rotate\n    / skewX\n    / skewY\n\nmatrix\n    = \"matrix\" wsp* \"(\" wsp*\n        a:number commaWsp\n        b:number commaWsp\n        c:number commaWsp\n        d:number commaWsp\n        e:number commaWsp\n        f:number wsp* \")\"\n    {\n        return [\n            a, c, e,\n            b, d, f\n        ];\n    }\n\ntranslate\n    = \"translate\" wsp* \"(\" wsp* tx:number ty:commaWspNumber? wsp* \")\"\n    {\n        return [\n            1, 0, tx,\n            0, 1, ty || 0\n        ];\n    }\n\nscale\n    = \"scale\" wsp* \"(\" wsp* sx:number sy:commaWspNumber? wsp* \")\"\n    {\n        return [\n            sx, 0,                     0,\n            0,  sy === null ? sx : sy, 0\n        ];\n    }\n\nrotate\n    = \"rotate\" wsp* \"(\" wsp* angle:number c:commaWspTwoNumbers? wsp* \")\"\n    {\n        var cos = Math.cos(deg2rad * angle);\n        var sin = Math.sin(deg2rad * angle);\n        if (c !== null) {\n            var [x, y] = c;\n            return [\n                cos, -sin, cos * -x + -sin * -y + x,\n                sin,  cos, sin * -x +  cos * -y + y\n            ];\n        }\n        return [\n            cos, -sin, 0,\n            sin,  cos, 0\n        ];\n    }\n\nskewX\n    = \"skewX\" wsp* \"(\" wsp* angle:number wsp* \")\"\n    {\n        return [\n            1, Math.tan(deg2rad * angle), 0,\n            0, 1,                         0\n        ];\n    }\n\nskewY\n    = \"skewY\" wsp* \"(\" wsp* angle:number wsp* \")\"\n    {\n        return [\n            1,                         0, 0,\n            Math.tan(deg2rad * angle), 1, 0\n        ];\n    }\n\nnumber\n    = f:(sign? floatingPointConstant) { return parseFloat(f.join(\"\")); }\n    / i:(sign? integerConstant) { return parseInt(i.join(\"\")); }\n\ncommaWspNumber\n    = commaWsp n:number { return n; }\n\ncommaWspTwoNumbers\n    = commaWsp n1:number commaWsp n2:number { return [n1, n2]; }\n\ncommaWsp\n    = (wsp+ comma? wsp*) / (comma wsp*)\n\ncomma\n    = \",\"\n\nintegerConstant\n    = ds:digitSequence { return ds.join(\"\"); }\n\nfloatingPointConstant\n    = f:(fractionalConstant exponent?) { return f.join(\"\"); }\n    / d:(digitSequence exponent) { return d.join(\"\"); }\n\nfractionalConstant \"fractionalConstant\"\n    = d1:digitSequence? \".\" d2:digitSequence { return [d1 ? d1.join(\"\") : null, \".\", d2.join(\"\")].join(\"\"); }\n    / d:digitSequence \".\" { return d.join(\"\"); }\n\nexponent\n    =  e:([eE] sign? digitSequence) { return [e[0], e[1], e[2].join(\"\")].join(\"\"); }\n\nsign\n    = [+-]\n\ndigitSequence\n    = digit+\n\ndigit\n    = [0-9]\n\nwsp\n    = [\\\\u0020\\\\u0009\\\\u000D\\\\u000A]\n`);\n\nfunction appendTransform(transform) {\n    if (transform) {\n        if (typeof transform === \"string\") {\n            try {\n                const [a, c, e, b, d, f] = transformParser.parse(transform);\n                pooledMatrix.append(...[a, b, c, d, e, f]);\n            } catch (e) {\n                console.error(e);\n            }\n        } else {\n            pooledMatrix.appendTransform(\n                transform.x + transform.originX,\n                transform.y + transform.originY,\n                transform.scaleX,\n                transform.scaleY,\n                transform.rotation,\n                transform.skewX,\n                transform.skewY,\n                transform.originX,\n                transform.originY,\n            );\n        }\n    }\n}\n\nfunction universal2axis(universal, axisX, axisY, defaultValue) {\n    let coords = [];\n    let x;\n    let y;\n    if (_.isString(universal)) {\n        coords = universal.split(/\\s*,\\s*/);\n        if (coords.length === 2) {\n            x = +coords[0];\n            y = +coords[1];\n        } else if (coords.length === 1) {\n            x = y = +coords[0];\n        }\n    } else if (_.isNumber(universal)) {\n        x = y = universal;\n    }\n\n    axisX = +axisX;\n    if (!isNaN(axisX)) {\n        x = axisX;\n    }\n\n    axisY = +axisY;\n    if (!isNaN(axisY)) {\n        y = axisY;\n    }\n\n    return [x || defaultValue || 0, y || defaultValue || 0];\n}\n\nexport function props2transform(props) {\n    if (props && typeof props === \"string\") {\n        return props;\n    }\n    const [originX, originY] = universal2axis(\n        props.origin,\n        props.originX,\n        props.originY,\n    );\n    const [scaleX, scaleY] = universal2axis(\n        props.scale,\n        props.scaleX,\n        props.scaleY,\n        1,\n    );\n    const [skewX, skewY] = universal2axis(props.skew, props.skewX, props.skewY);\n    const [translateX, translateY] = universal2axis(\n        props.translate,\n        _.isNil(props.translateX) ? props.x || 0 : props.translateX,\n        _.isNil(props.translateY) ? props.y || 0 : props.translateY,\n    );\n\n    return {\n        rotation: +props.rotation || 0,\n        scaleX: scaleX,\n        scaleY: scaleY,\n        originX: originX,\n        originY: originY,\n        skewX: skewX,\n        skewY: skewY,\n        x: translateX,\n        y: translateY,\n    };\n}\n\nexport default function(props) {\n    return transformToMatrix(\n        props2transform(props),\n        props.transform ? props2transform(props.transform) : null,\n    );\n}\n"]},"metadata":{},"sourceType":"script"}