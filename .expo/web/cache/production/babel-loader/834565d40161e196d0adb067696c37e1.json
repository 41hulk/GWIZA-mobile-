{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.Recording=exports.RECORDING_OPTIONS_PRESET_LOW_QUALITY=exports.RECORDING_OPTIONS_PRESET_HIGH_QUALITY=exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE=exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED=exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE=exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT=exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX=exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH=exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM=exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW=exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3=exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM=exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD=exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC=exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC=exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB=exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB=exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP=exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT=void 0;var _objectSpread2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _reactNative=require(\"react-native\");var _AV=require(\"../AV\");var _AudioAvailability=require(\"./AudioAvailability\");var _Sound=require(\"./Sound\");var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT=0;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP=1;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4=2;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB=3;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB=4;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF=5;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS=6;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP=7;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS=8;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS;var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM=9;exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM=RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM;var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT=0;exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT=RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT;var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB=1;exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB=RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB;var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB=2;exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB=RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB;var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC=3;exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC=RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC;var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC=4;exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC=RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC;var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD=5;exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD=RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM='lpcm';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM=RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3='ac-3';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3=RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3='cac3';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3=RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4='ima4';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4=RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC='aac ';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP='celp';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC='hvxc';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ='twvq';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3='MAC3';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6='MAC6';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW='ulaw';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW=RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW='alaw';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW=RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN='QDMC';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN=RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2='QDM2';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2=RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM='Qclp';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM=RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1='.mp1';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2='.mp2';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3='.mp3';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS='alac';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS=RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE='aach';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD='aacl';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD='aace';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR='aacf';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2='aacg';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2='aacp';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL='aacs';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR='samr';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR=RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB='sawb';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB=RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE='AUDB';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE=RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC='ilbc';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC=RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA=0x6d730011;exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA=RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM=0x6d730031;exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM=RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3='aes3';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3=RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3;var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3='ec-3';exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3=RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3;var RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN=0;exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN=RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN;var RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW=0x20;exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW=RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW;var RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM=0x40;exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM=RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM;var RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH=0x60;exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH=RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH;var RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX=0x7f;exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX=RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX;var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT=0;exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT=RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT;var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE=1;exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE=RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE;var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED=2;exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED=RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED;var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE=3;exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE=RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE;var RECORDING_OPTIONS_PRESET_HIGH_QUALITY={android:{extension:'.m4a',outputFormat:RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,audioEncoder:RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,sampleRate:44100,numberOfChannels:2,bitRate:128000},ios:{extension:'.caf',audioQuality:RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,sampleRate:44100,numberOfChannels:2,bitRate:128000,linearPCMBitDepth:16,linearPCMIsBigEndian:false,linearPCMIsFloat:false}};exports.RECORDING_OPTIONS_PRESET_HIGH_QUALITY=RECORDING_OPTIONS_PRESET_HIGH_QUALITY;var RECORDING_OPTIONS_PRESET_LOW_QUALITY={android:{extension:'.3gp',outputFormat:RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,audioEncoder:RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,sampleRate:44100,numberOfChannels:2,bitRate:128000},ios:{extension:'.caf',audioQuality:RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,sampleRate:44100,numberOfChannels:2,bitRate:128000,linearPCMBitDepth:16,linearPCMIsBigEndian:false,linearPCMIsFloat:false}};exports.RECORDING_OPTIONS_PRESET_LOW_QUALITY=RECORDING_OPTIONS_PRESET_LOW_QUALITY;var _recorderExists=false;var Recording=function(){function Recording(){var _this=this;(0,_classCallCheck2.default)(this,Recording);this._canRecord=false;this._isDoneRecording=false;this._finalDurationMillis=0;this._uri=null;this._onRecordingStatusUpdate=null;this._progressUpdateTimeoutVariable=null;this._progressUpdateIntervalMillis=_AV._DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;this._options=null;this._cleanupForUnloadedRecorder=function _callee(finalStatus){return _regenerator.default.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_this._canRecord=false;_this._isDoneRecording=true;_this._finalDurationMillis=finalStatus.durationMillis;_recorderExists=false;if(_reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording){_reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(null);}_this._disablePolling();_context.next=8;return _regenerator.default.awrap(_this.getStatusAsync());case 8:return _context.abrupt(\"return\",_context.sent);case 9:case\"end\":return _context.stop();}}},null,this);};this._pollingLoop=function _callee2(){return _regenerator.default.async(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!((0,_AudioAvailability.isAudioEnabled)()&&_this._canRecord&&_this._onRecordingStatusUpdate!=null)){_context2.next=10;break;}_this._progressUpdateTimeoutVariable=setTimeout(_this._pollingLoop,_this._progressUpdateIntervalMillis);_context2.prev=2;_context2.next=5;return _regenerator.default.awrap(_this.getStatusAsync());case 5:_context2.next=10;break;case 7:_context2.prev=7;_context2.t0=_context2[\"catch\"](2);_this._disablePolling();case 10:case\"end\":return _context2.stop();}}},null,this,[[2,7]]);};this.getStatusAsync=function _callee3(){var status;return _regenerator.default.async(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(!_this._canRecord){_context3.next=2;break;}return _context3.abrupt(\"return\",_this._performOperationAndHandleStatusAsync(function(){return _reactNative.NativeModules.ExponentAV.getAudioRecordingStatus();}));case 2:status={canRecord:false,isRecording:false,isDoneRecording:_this._isDoneRecording,durationMillis:_this._finalDurationMillis};_this._callOnRecordingStatusUpdateForNewStatus(status);return _context3.abrupt(\"return\",status);case 5:case\"end\":return _context3.stop();}}},null,this);};}(0,_createClass2.default)(Recording,[{key:\"_disablePolling\",value:function _disablePolling(){if(this._progressUpdateTimeoutVariable!=null){clearTimeout(this._progressUpdateTimeoutVariable);this._progressUpdateTimeoutVariable=null;}}},{key:\"_enablePollingIfNecessaryAndPossible\",value:function _enablePollingIfNecessaryAndPossible(){if((0,_AudioAvailability.isAudioEnabled)()&&this._canRecord&&this._onRecordingStatusUpdate!=null){this._disablePolling();this._pollingLoop();}}},{key:\"_callOnRecordingStatusUpdateForNewStatus\",value:function _callOnRecordingStatusUpdateForNewStatus(status){if(this._onRecordingStatusUpdate!=null){this._onRecordingStatusUpdate(status);}}},{key:\"_performOperationAndHandleStatusAsync\",value:function _performOperationAndHandleStatusAsync(operation){var status;return _regenerator.default.async(function _performOperationAndHandleStatusAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:(0,_AudioAvailability.throwIfAudioIsDisabled)();if(!this._canRecord){_context4.next=9;break;}_context4.next=4;return _regenerator.default.awrap(operation());case 4:status=_context4.sent;this._callOnRecordingStatusUpdateForNewStatus(status);return _context4.abrupt(\"return\",status);case 9:throw new Error('Cannot complete operation because this recorder is not ready to record.');case 10:case\"end\":return _context4.stop();}}},null,this);}},{key:\"setOnRecordingStatusUpdate\",value:function setOnRecordingStatusUpdate(onRecordingStatusUpdate){this._onRecordingStatusUpdate=onRecordingStatusUpdate;if(onRecordingStatusUpdate==null){this._disablePolling();}else{this._enablePollingIfNecessaryAndPossible();}this.getStatusAsync();}},{key:\"setProgressUpdateInterval\",value:function setProgressUpdateInterval(progressUpdateIntervalMillis){this._progressUpdateIntervalMillis=progressUpdateIntervalMillis;this.getStatusAsync();}},{key:\"prepareToRecordAsync\",value:function prepareToRecordAsync(){var options,extensionRegex,_ref,uri,status,currentStatus,_args5=arguments;return _regenerator.default.async(function prepareToRecordAsync$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:options=_args5.length>0&&_args5[0]!==undefined?_args5[0]:RECORDING_OPTIONS_PRESET_LOW_QUALITY;(0,_AudioAvailability.throwIfAudioIsDisabled)();if(!_recorderExists){_context5.next=4;break;}throw new Error('Only one Recording object can be prepared at a given time.');case 4:if(!this._isDoneRecording){_context5.next=6;break;}throw new Error('This Recording object is done recording; you must make a new one.');case 6:if(!(!options||!options.android||!options.ios)){_context5.next=8;break;}throw new Error('You must provide recording options for android and ios in order to prepare to record.');case 8:extensionRegex=/^\\.\\w+$/;if(!(!options.android.extension||!options.ios.extension||!extensionRegex.test(options.android.extension)||!extensionRegex.test(options.ios.extension))){_context5.next=11;break;}throw new Error(\"Your file extensions must match \"+extensionRegex.toString()+\".\");case 11:if(this._canRecord){_context5.next=28;break;}if(_reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording){_reactNative.NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(this._cleanupForUnloadedRecorder);}_context5.next=15;return _regenerator.default.awrap(_reactNative.NativeModules.ExponentAV.prepareAudioRecorder(options));case 15:_ref=_context5.sent;uri=_ref.uri;status=_ref.status;_recorderExists=true;this._uri=uri;this._options=options;this._canRecord=true;currentStatus=(0,_objectSpread2.default)({},status,{canRecord:true});this._callOnRecordingStatusUpdateForNewStatus(currentStatus);this._enablePollingIfNecessaryAndPossible();return _context5.abrupt(\"return\",currentStatus);case 28:throw new Error('This Recording object is already prepared to record.');case 29:case\"end\":return _context5.stop();}}},null,this);}},{key:\"startAsync\",value:function startAsync(){return _regenerator.default.async(function startAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:return _context6.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return _reactNative.NativeModules.ExponentAV.startAudioRecording();}));case 1:case\"end\":return _context6.stop();}}},null,this);}},{key:\"pauseAsync\",value:function pauseAsync(){return _regenerator.default.async(function pauseAsync$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:return _context7.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return _reactNative.NativeModules.ExponentAV.pauseAudioRecording();}));case 1:case\"end\":return _context7.stop();}}},null,this);}},{key:\"stopAndUnloadAsync\",value:function stopAndUnloadAsync(){var finalStatus;return _regenerator.default.async(function stopAndUnloadAsync$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:if(this._canRecord){_context8.next=6;break;}if(!this._isDoneRecording){_context8.next=5;break;}throw new Error('Cannot unload a Recording that has already been unloaded.');case 5:throw new Error('Cannot unload a Recording that has not been prepared.');case 6:_context8.next=8;return _regenerator.default.awrap(_reactNative.NativeModules.ExponentAV.stopAudioRecording());case 8:finalStatus=_context8.sent;_context8.next=11;return _regenerator.default.awrap(_reactNative.NativeModules.ExponentAV.unloadAudioRecorder());case 11:return _context8.abrupt(\"return\",this._cleanupForUnloadedRecorder(finalStatus));case 12:case\"end\":return _context8.stop();}}},null,this);}},{key:\"getURI\",value:function getURI(){return this._uri;}},{key:\"createNewLoadedSound\",value:function createNewLoadedSound(){var initialStatus,onPlaybackStatusUpdate,_args9=arguments;return _regenerator.default.async(function createNewLoadedSound$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:initialStatus=_args9.length>0&&_args9[0]!==undefined?_args9[0]:{};onPlaybackStatusUpdate=_args9.length>1&&_args9[1]!==undefined?_args9[1]:null;console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");return _context9.abrupt(\"return\",this.createNewLoadedSoundAsync(initialStatus,onPlaybackStatusUpdate));case 4:case\"end\":return _context9.stop();}}},null,this);}},{key:\"createNewLoadedSoundAsync\",value:function createNewLoadedSoundAsync(){var initialStatus,onPlaybackStatusUpdate,_args10=arguments;return _regenerator.default.async(function createNewLoadedSoundAsync$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:initialStatus=_args10.length>0&&_args10[0]!==undefined?_args10[0]:{};onPlaybackStatusUpdate=_args10.length>1&&_args10[1]!==undefined?_args10[1]:null;if(!(this._uri==null||!this._isDoneRecording)){_context10.next=4;break;}throw new Error('Cannot create sound when the Recording has not finished!');case 4:return _context10.abrupt(\"return\",_Sound.Sound.createAsync({uri:this._uri},initialStatus,onPlaybackStatusUpdate,false));case 5:case\"end\":return _context10.stop();}}},null,this);}}]);return Recording;}();exports.Recording=Recording;","map":{"version":3,"sources":["../../../src/av/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import { NativeModules } from 'react-native';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  PlaybackStatus,\n  PlaybackStatusToSet,\n} from '../AV';\n\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\n\nimport { Sound } from './Sound';\n\nexport type RecordingOptions = {\n  android: {\n    extension: string;\n    outputFormat: number;\n    audioEncoder: number;\n    sampleRate?: number;\n    numberOfChannels?: number;\n    bitRate?: number;\n    maxFileSize?: number;\n  };\n  ios: {\n    extension: string;\n    outputFormat?: string | number;\n    audioQuality: number;\n    sampleRate: number;\n    numberOfChannels: number;\n    bitRate: number;\n    bitRateStrategy?: number;\n    bitDepthHint?: number;\n    linearPCMBitDepth?: number;\n    linearPCMIsBigEndian?: boolean;\n    linearPCMIsFloat?: boolean;\n  };\n};\n\n// TODO: consider changing these to enums\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO: For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as\n// well?\nexport type RecordingStatus = {\n  canRecord: boolean;\n  isRecording: boolean;\n  isDoneRecording: boolean;\n  durationMillis: number;\n};\n\nlet _recorderExists: boolean = false;\n\nexport class Recording {\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    // $FlowFixMe(greg): durationMillis is not always defined\n    this._finalDurationMillis = finalStatus.durationMillis;\n    _recorderExists = false;\n    if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n      NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(null);\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      );\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        NativeModules.ExponentAV.getAudioRecordingStatus()\n      );\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n        NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await NativeModules.ExponentAV.prepareAudioRecorder(options);\n\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.startAudioRecording()\n    );\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.pauseAudioRecording()\n    );\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    const finalStatus = await NativeModules.ExponentAV.stopAudioRecording();\n    await NativeModules.ExponentAV.unloadAudioRecorder();\n    return this._cleanupForUnloadedRecorder(finalStatus);\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}